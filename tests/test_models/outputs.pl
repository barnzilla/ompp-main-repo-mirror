# Copyright (c) 2013 OpenM++
# This code is licensed under MIT license (see LICENSE.txt for details)

# Run this script from the /openm/test_models folder
# Argument is the name of a model, located in a sister directory of test_models, e.g. Alpha1

# Perl script to display tables from a previous run using inputs.pl.

my $version = 1.0;

if ( $#ARGV+1 != 1 ) {
	print "outputs version $version\n";
	print "outputs modelname\n";
	exit -1;
}

# name of model (from first argument)
my $model_name = $ARGV[0];

# for diagnostics
my $debug = 0;

# sqlite3 executable
my $sqlite_exe = "../../bin/sqlite3.exe";

# model database
my $model_db = $model_name . ".sqlite";

# sql source to insert model metadata
my $create_model_sql =  "../build/${model_name}/src/" . $model_name . "_create_model.sql";

# sql source to insert model parameters (generated by this script)
my $insert_param_sql = "../build/${model_name}/src/" . $model_name . "_insert_param.sql";

# sql source to display tables (generated by this script)
my $display_tables_sql = $model_name . "_display_tables.sql";

# extract table information from metadata sql script

my $model_time_stamp;
my @tables;
my @table_value_tables;

open(CREATE_MODEL, "<${create_model_sql}") || die "Fail to open ${create_model_sql}\n";
while (<CREATE_MODEL>) {
	if ( m/model timestamp: _([0-9]+)_/ ) {
		# note model time stamp
		$model_time_stamp = $1;
	}
	if ( m/^INSERT INTO table_dic .*, ['](\w+)/ ) {
		# extracts the word inside  the first '' delimited string
		push @tables, $1;
	}
	if ( m/^CREATE TABLE (\w+)/ ) {
		my $sql_table = $1;
		if ( $sql_table =~ /_v[0-9]+_/ ) {
			# based on name, this is the table view
			push @table_value_tables, $sql_table;
		}
	}

	print SQLITE;
}
close(CREATE_MODEL);

if ( $debug ) {
	print "\nTABLES:\n";
	foreach my $table (@tables) { print "$table\n"; }

	print "\nTABLE VALUE TABLES:\n";
	foreach my $table_value_table (@table_value_tables) { print "$table_value_table\n"; }
}

# Create display_tables.sql script
open(DISPLAY_TABLE_SQL, ">${display_tables_sql}")  || die("Failed to create ${display_tables_sql}");
for (my $j=0; $j<=$#tables; $j++) {
	my $table_id = $j;
	my $table_name = @tables[$j];

	my $table_value_table = @table_value_tables[$j];
	print DISPLAY_TABLE_SQL "SELECT '${table_name}';", "\n";
	print DISPLAY_TABLE_SQL "SELECT * FROM ${table_value_table};", "\n";
}
close(DISPLAY_TABLE_SQL);


if ( $debug ) {
	print "Display output tables in sqlite database - begin", "\n\n";
}
open(DISPLAY_TABLE_SQL, "<${display_tables_sql}") || die "Failed to open ${display_tables_sql}\n";
open(SQLITE, "|${sqlite_exe} ${model_db}") || "Failed to open pipe: |${sqlite_exe} ${model_db}\n";
while (<DISPLAY_TABLE_SQL>) {
	print SQLITE;
}
close(DISPLAY_TABLE_SQL);
close(SQLITE); # close pipe to sqlite executable so that error message line indicators correspond to the sql source file
if ( $debug ) {
	print "Display output tables in sqlite database - end", "\n\n";
}
unlink($display_tables_sql);

/*****************************************************************************
*	IDMM™: Infectious Disease Microsimulation Model
*
*Revisions:
* +-----+----------+---------------------------------------------------------+
* | Who |   Date   | Description                                             |
* +-----+----------+---------------------------------------------------------+
* | SFG | 02/02/19 | Created                                                 |
* | SFG | 03/11/28 | Cosmetic changes                                        |
* | SFG | 04/12/27 | Use Modgen memory enhancements                          |
* +-----+----------+---------------------------------------------------------+
*
******************************************************************************/

//LABEL (IDMM, EN) Core simulation functions

/* NOTE(IDMM, EN)
	This module contains the core of the IDMM model.  It controls the simulation engine. 
*/

// These are the languages in which IDMM can be viewed.
languages 
{
	EN, // English
	FR	// Français
};

version 2, 0, 0, 0;

model_type time_based, just_in_time;

// types
time_type		float;

real_type		float;
counter_type	ushort;
integer_type	short;
index_type		ushort;

// options
options bounds_errors=off;
options packing_level=2;
options event_trace=on;



actor_set Host asAllHosts; //EN All Hosts


void PreSimulation()
{
	// Note that actors cannot be used in PreSimulation, since Modgen has not
	// yet created the associated internal structures.
	// Only parameters (and global varaibles) can be manipulated in PreSimulation.
	// This is a corollary of the fact that PreSimulation is shared 
	// among all replicates / sub-samples.  In other words it is called
	// only once in the course of a model execution.
}


void Simulation()
{
	// Buffer for reporting progress
	const 	size_t nBufSize = {255};
	char 	szBuffer[nBufSize];

	int 	nJ = {0};

	// Note replicate number for progress reporting
	int nReplicate = GetReplicate();

	StopEventTrace();

	// Create the starting population
	sprintf_s(szBuffer, nBufSize, "%s %d: %s", ModelString("S_MODEL_REPLICATE"), nReplicate, ModelString("S_MODEL_START"));
	ProgressMessage( szBuffer );

	// Create the single ticker actor
	auto prTicker = new Ticker();
	prTicker->Start();

	// Create the Host actors
	for ( nJ = 0; nJ < NumberOfHosts; nJ++ ) 
	{
		auto prHost = new Host();
		prHost->Start();
	}

	int nHosts = asAllHosts->Count();
	for ( nJ = 0; nJ < nHosts; nJ++ ) 
	{
		auto prHost = asAllHosts->Item( nJ );
		for (int nK = 0; nK < ContactsOutPerHost; nK++ ) 
		{
			// Choose a host randomly from all hosts
			auto prContact = asAllHosts->GetRandom( RandUniform(3) );
			// Add it to the outgoing contacts link.
			// Note that if the contact happens to already be a contact, it will not be added.
			// That's because Modgen links can contain no duplicates.
			// Modgen links are like mathematical sets.
			prHost->mlContactsOut->Add( prContact );
		}
	}


	sprintf_s(szBuffer, nBufSize, "%s %d: %s", ModelString("S_MODEL_REPLICATE"), nReplicate, ModelString("S_MODEL_SIMULATION"));
	ProgressMessage( szBuffer );

	// event loop
	double dCurrentTime = {TIME_INFINITE};
	double dStartTime = {TIME_INFINITE};

	int nLastProgressPercent = {-1};
	int nThisProgressPercent = {-1};

	while ( !gpoEventQueue->Empty() ) 
	{

		// get the time of next event, verify against the simulation end
		dCurrentTime = gpoEventQueue->NextEvent();

		// Note the start time (time of first event) for progress indicator
		if ( dStartTime == TIME_INFINITE )
		{
			dStartTime = dCurrentTime;
		}

		if ( dCurrentTime > SIMULATION_END() || gbInterrupted || gbCancelled || gbErrors )
		{
			if (dCurrentTime > SIMULATION_END())
			{
				// age all actors to the simulation end time
				gpoEventQueue->WaitUntilAllActors( SIMULATION_END() );
			}

			sprintf_s(szBuffer, nBufSize, "%s %d: %s", ModelString("S_MODEL_REPLICATE"), nReplicate, ModelString("S_MODEL_FINISH"));
			ProgressMessage( szBuffer );

			gpoEventQueue->FinishAllActors();
		}
		else 
		{
			// age all actors to the time of next event
			gpoEventQueue->WaitUntil( dCurrentTime );

			// implement the next event
			gpoEventQueue->Implement();
		}

		// Update progress indicator only if the integer percentage complete changes
		// (updates to the progress bar at every event are expensive).
		nThisProgressPercent = (int)( 100 * ( dCurrentTime - dStartTime ) /
		                                    ( SIMULATION_END() - dStartTime ) );

		if ( nThisProgressPercent > nLastProgressPercent )
		{
			TimeReport( dCurrentTime );	// update simulation progress
			nLastProgressPercent = nThisProgressPercent;
		}
	}
}


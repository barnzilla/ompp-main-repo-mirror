/**
 * @file    Agent.h
 * Declares the Agent class and associated classes and templates
 *         
 */
// Copyright (c) 2013-2015 OpenM++
// This code is licensed under the MIT license (see LICENSE.txt for details)

#pragma once
#include <list>
#include <forward_list>
#include <sstream>
#include <cassert>
#include "globals0.h" // for ModelExit
#include "om_types0.h" // for Time

using namespace std;

/**
 * Base agent.
 */
class BaseAgent
{
public:

    /**
     * Assign initial value to all data members in agent, with no side-effects. The function
     * definition is specific to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_data_members() = 0;

    /**
     * Assign unique entity_id to agent as part of initialization.
     */
    virtual void om_set_entity_id() = 0;

    /**
     * Get unique entity_id of agent.
     */
    virtual int om_get_entity_id() = 0;

    /**
     * Get current time of agent.
     */
    virtual Time om_get_time() = 0;

    /**
     * Initialize time and age as part of entity initialization.
     */
    virtual void om_initialize_time_and_age() = 0;

    /**
     * Assign offset of each attribute and increment in the entity.
     * 
     * This function is called exactly once for each kind of entity to assign static members which
     * contain the offset of each attribute within the containing entity. This offset is used to
     * access the containing entity to invoke side-effects when the value of the attribute changes.
     * These offsets are fixed at compile time but the value cannot cannot be determined by the C++
     * compiler at the time of template instantiation.
     */
    virtual void om_assign_member_offsets() = 0;

    /**
     * Insert agent into entity sets of this agent type. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_entity_sets() = 0;

    /**
     * Initialize value_in values for agentvars used in tables. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_tables() = 0;

    /**
     * Compute occurrence time for each event in agent. The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_events() = 0;

    /**
     * Remove agent from entity sets of this agent type. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_entity_sets() = 0;

    /**
     * Complete all pending table updates. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_tables() = 0;

    /**
     * Initialize identity attributes by evaluating their associated expressions.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_identity_attributes() = 0;

    /**
     * Initialize derived attributes by evaluating injected code.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_derived_attributes() = 0;

    /**
     * Reset derived attributes by evaluating injected code.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_reset_derived_attributes() = 0;

    /**
     * Finalize agent events (remove from event queue). The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_finalize_events() = 0;

    /**
     * Sets all links in the agent to nullptr when the agent leaves the simulation.
     */
    virtual void om_finalize_links() = 0;

    /**
     * Empties all multilinks in the agent when the agent leaves the simulation.
     */
    virtual void om_finalize_multilinks() = 0;

    /**
     * Age the agent to the given time.
     *
     * @param t The target time.
     */
    virtual void age_agent( Time t ) = 0;

    /**
     * Add the agent to the zombie list for agents of this type.
     */
    virtual void make_zombie() = 0;

    /**
     * Age all agents to the given time.
     * 
     * If originating_entity_id is not supplied, no check for time running backwards is performed
     * 
     * @param t                     The target time.
     * @param originating_entity_id Identifier of the entity within which the event occurred.
     */
    static void age_all_agents( Time t, int originating_entity_id = -1, int originating_event_id = -1)
    {
        assert(agents);
        for ( auto agent : *agents ) {
            if (agent->om_get_entity_id() == originating_entity_id) {
                // This is the entity within which the event occurred.
                // Check for time running backwards in the entity within which the event occurred
                if (t < agent->om_get_time()) {
                    // The time of this event is in the local past of the entity within which the event occurs.
                    // This is an error in model logic.
                    // Write log message and throw run-time exception.
                    handle_backwards_time(
                        t,
                        agent->om_get_time(),
                        originating_event_id,
                        originating_entity_id
                    );
                }
            }
            agent->age_agent( t );
        }
    }

    /**
     * Move all agents from zombie lists to corresponding available list.
     * 
     * The function definition is generated by the openM++ compiler.
     */
    static void free_all_zombies();

    /**
     * Adds the agent to the list of active agents.
     */
    void make_active()
    {
        assert(agents);
        agents->push_front( this );
        iter_in_agents = agents->begin();
    }

    /**
     * Removes the agent from the list of active agents.
     */    
    void make_inactive()
    {
        assert(agents);
        agents->erase( iter_in_agents );
    }

    /**
     * Initialize all attributes of the entity.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the beginning of a member function named Start().
     */
    void initialize_attributes()
    {
        om_active = false;
        om_initialize_data_members();
        om_set_entity_id();
        om_initialize_time_and_age();
        om_initialize_derived_attributes();
        om_initialize_identity_attributes();
    }

    /**
     * Have the entity enter the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the end of a member function named Start().
     */
    void enter_simulation()
    {
        om_reset_derived_attributes();
        om_initialize_identity_attributes();
        om_initialize_entity_sets();
        om_initialize_tables();
        om_initialize_events();
        make_active();
        om_active = true;
    }

    /**
     * Have the entity exit the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle.
     */
    void exit_simulation()
    {
        om_finalize_entity_sets();
        om_finalize_tables();
        om_finalize_events();
        om_active = false;
        om_finalize_links();
        om_finalize_multilinks();
        make_inactive();
        make_zombie();
    }

    /**
     * Have all entities exit the simulation.
     * 
     * Can be called by framework model code as part of the simulation or case lifecycle.
     */
    static void exit_simulation_all()
    {
        // Iteration over agents needs to be robust to deletion of current iterator.
        assert(agents);
        auto it = agents->begin();
        while (it != agents->end()) {
            auto agent = *it;
            ++it; // increment iterator before erasing it from agents
            agent->exit_simulation();
        }
    }

    /**
     * Number of active agents.
     *
     * @return An int.
     */
    static int om_active_agents()
    {
        assert(agents);
        return agents->size();
    }

    /**
     * True if agent is active in the simulation.
     */
    bool om_active;

    /**
     * Initializes run-time before simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of agent has
     * associated objects.
     */
    static void initialize_simulation_runtime();

    /**
     * Cleans up run-time after simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of agent has
     * associated objects.
     */
    static void finalize_simulation_runtime();

private:

    /**
     * The iterator of this agent in BaseAgent::agents.
     */
    list<BaseAgent *>::iterator iter_in_agents;

    /**
     * Active agents.
     */
    static thread_local list<BaseAgent *> *agents;
};

/**
 * Agent. Only instances of derived classes of Agent are actually created.
 *
 * @tparam A Type of a.
 */
template<typename A>
class Agent : public BaseAgent
{
public:

    /**
     * Agent allocation operator. This allocator recycles agents of the given type. Note that the
     * argument of new() is required for the correct signature but is not required or used.
     *
     * @param count Size of object (required for correct signature)
     *
     * @return The allocated object.
     */
    void *operator new( size_t count )
    {
		A *agent = nullptr;
        assert(available);
        if ( available->empty() ) {
			agent = ::new A;
        }
        else {
            agent = available->front();
            available->pop_front();
        }

        return agent;
    }

    void make_zombie()
    {
        assert(zombies);
        zombies->push_front( (A *)this );
    }

    /**
     * Free zombies. Move all zombie agents to the available list for re-use.
     */
    static void free_zombies()
    {
        assert(zombies);
        assert(available);
        while ( ! zombies->empty() ) {
            // invoke destructor on zombie to invoke member destructors
            // e.g. for multi-links to avoid memory leaks
            zombies->front()->~A();
            available->push_front( zombies->front() );
            zombies->pop_front();
        }
    }

    static thread_local forward_list<A *> *zombies;
    static thread_local forward_list<A *> *available;

};


/**
* Agent zombie list (definition)
*/

template<typename A>
thread_local forward_list<A *> *Agent<A>::zombies;

/**
* Agent available list (definition)
*/

template<typename A>
thread_local forward_list<A *> *Agent<A>::available;


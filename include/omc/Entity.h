/**
 * @file    Entity.h
 * Declares the Entity class and associated classes and templates
 *         
 */
// Copyright (c) 2013-2022 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

#pragma once
#include <list>
#include <forward_list>
#include <unordered_set>
#include <sstream>
#include <cassert>
#include "libopenm/omModel.h" // for theTrace
#include "globals0.h" // for handle_backwards_time
#include "om_types0.h" // for Time

/**
 * Base entity.
 */
class BaseEntity
{
public:
    /**
     * Explicitly declared virtual destructor
     * to allow safe delete of instances of derived classes.
     */
    virtual ~BaseEntity() = default;

    /**
     * Assign initial value to all data members in entity, with no side-effects. The function
     * definition is specific to each kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_data_members() = 0;

    /**
     * Get entity name
     */
    virtual const char * om_get_entity_name() = 0;

    /**
     * Assign unique entity_id to entity as part of initialization.
     */
    virtual void om_set_entity_id() = 0;

    /**
     * Get unique entity_id of entity.
     */
    virtual int om_get_entity_id() = 0;

    /**
     * Get current time of entity.
     */
    virtual Time om_get_time() = 0;

    /**
     * Get current age of entity.
     */
    virtual Time om_get_age() = 0;

    /**
     * Initialize time and age as part of entity initialization.
     */
    virtual void om_initialize_time_and_age() = 0;

    /**
     * Assign offset of each attribute and increment in the entity.
     * 
     * This function is called exactly once for each kind of entity to assign static members which
     * contain the offset of each attribute within the containing entity. This offset is used to
     * access the containing entity to invoke side-effects when the value of the attribute changes.
     * These offsets are fixed at compile time but the value cannot cannot be determined by the C++
     * compiler at the time of template instantiation.
     */
    virtual void om_assign_member_offsets() = 0;

    /**
     * Insert entity into entity sets of this entity type. The function definition is specific
     * to each kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_entity_sets() = 0;

    /**
     * Initialize value_in values for attributes used in tables. The function definition is specific
     * to each kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_tables() = 0;

    /**
     * Compute occurrence time for each event in entity. The function definition is specific to each
     * kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_events() = 0;

    /**
     * Remove entity from entity sets of this entity type. The function definition is specific to each kind of entity
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_entity_sets() = 0;

    /**
     * Complete all pending table updates. The function definition is specific to each kind of entity
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_tables() = 0;

    /**
     * Initialize identity attributes by evaluating their associated expressions.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_identity_attributes() = 0;

    /**
     * Initialize derived attributes by evaluating injected code.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_derived_attributes() = 0;

    /**
     * Check that starting value of time is valid and raise run-time error if not.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_check_starting_time() = 0;

    /**
     * Reset derived attributes by evaluating injected code.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_reset_derived_attributes() = 0;

    /**
     * Finalize entity events (remove from event queue). The function definition is specific to each
     * kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_finalize_events() = 0;

    /**
     * Sets all links in the entity to nullptr when the entity leaves the simulation.
     */
    virtual void om_finalize_links() = 0;

    /**
     * Empties all multilinks in the entity when the entity leaves the simulation.
     */
    virtual void om_finalize_multilinks() = 0;

    /**
     * Does trace messages at start of entity lifecycle.
     */
    virtual void om_start_trace() = 0;

    /**
     * Age the entity to the given time.
     *
     * @param t The target time.
     */
    virtual void age_entity( Time t ) = 0;

    /**
     * Add the entity to the zombie list for entities of this type.
     */
    virtual void make_zombie() = 0;

    /**
     * Age all entities to the given time.
     * 
     * If originating_entity_id is not supplied, no check for time running backwards is performed
     * 
     * @param t                     The target time.
     * @param originating_entity_id Identifier of the entity within which the event occurred.
     */
    static void age_all_entities( Time t, int originating_entity_id = -1, int originating_event_id = -1)
    {
        assert(entities);
        for ( auto entity : *entities ) {
            if (entity->om_get_entity_id() == originating_entity_id) {
                // This is the entity within which the event occurred.
                // Check for time running backwards in the entity within which the event occurred
                if (t < entity->om_get_time()) {
                    // The time of this event is in the local past of the entity within which the event occurs.
                    // This is an error in model logic.
                    // Write log message and throw run-time exception.
                    handle_backwards_time(
                        t,
                        entity->om_get_time(),
                        originating_event_id,
                        originating_entity_id
                    );
                }
            }
            entity->age_entity( t );
        }
        // Note that global time is updated in framework module
        // by calling BaseEvent::set_global_time(t);
    }

    /**
     * Move all entities from zombie lists to corresponding available list.
     * 
     * The function definition is generated by the openM++ compiler.
     */
    static void free_all_zombies();

    /**
     * Adds the entity to the list of active entities.
     */
    void make_active()
    {
        assert(entities);
        entities->push_front( this );
        iter_in_entities = entities->begin();
    }

    /**
     * Removes the entity from the list of active entities.
     */    
    void make_inactive()
    {
        assert(entities);
        entities->erase(iter_in_entities);
    }

    /**
     * Initialize all attributes of the entity.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the beginning of a member function named Start().
     */
    void initialize_attributes()
    {
        om_active = false;
        om_initialize_data_members();
        om_set_entity_id();
        om_initialize_time_and_age();
        om_initialize_derived_attributes();
        om_initialize_identity_attributes();
    }

    /**
     * Have the entity enter the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the end of a member function named Start().
     */
    void enter_simulation()
    {
        om_check_starting_time();
        om_reset_derived_attributes();
        om_initialize_identity_attributes();
        om_initialize_entity_sets();
        om_initialize_tables();
        om_initialize_events();
        make_active();
        om_active = true;
        if constexpr (om_event_trace_capable) {
            extern double GetCaseSeed();
            if (event_trace_on) {
                event_trace_msg(
                    om_get_entity_name(),
                    (int)om_get_entity_id(),
                    (double)om_get_age(),
                    GetCaseSeed(),
                    "", // no associated event
                    -1, // no associated event
                    "enter_simulation",
                    om_get_time(), // the value of time in the entity before it enters the simulation
                    om_get_age(), // the value of age in the entity before it enters the simulation
                    get_global_time(),
                    et_msg_type::eEnterSimulation
                );
            }
        }
        om_start_trace();
    }

    /**
     * Have the entity exit the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle.
     */
    void exit_simulation()
    {
        if constexpr(om_event_trace_capable) {
            extern double GetCaseSeed();
            if (event_trace_on) {
                event_trace_msg(
                    om_get_entity_name(),
                    (int)om_get_entity_id(),
                    (double)om_get_age(),
                    GetCaseSeed(),
                    "", // no associated event
                    -1, // no associated event
                    "exit_simulation",
                    om_get_time(), // the value of time in the entity when it exits the simulation
                    om_get_age(), // the value of age in the entity when it exits the simulation
                    get_global_time(),
                    et_msg_type::eExitSimulation
                );
            }
        }
        om_finalize_entity_sets();
        om_finalize_tables();
        om_finalize_events();
        om_active = false;
        om_finalize_links();
        om_finalize_multilinks();
        make_inactive();
        make_zombie();
    }

    /**
     * Have all entities exit the simulation.
     * 
     * Can be called by framework model code as part of the simulation or case lifecycle.
     */
    static void exit_simulation_all()
    {
        // Iteration over entities needs to be robust to deletion of current iterator.
        assert(entities);
        auto it = entities->begin();
        while (it != entities->end()) {
            auto entity = *it;
            ++it; // increment iterator before erasing it from entities
            entity->exit_simulation();
        }
    }

    /**
     * Number of active entities.
     *
     * @return An int.
     */
    static size_t om_active_entities()
    {
        assert(entities);
        return entities->size();
    }

    /**
     * True if entity is active in the simulation.
     */
    bool om_active;

    /**
     * Allow or disallow access to null entity through null pointer
     *
     * If not allowed, will raise runtime exception.
     * If allowed (when evaluating identity attribute expressions),
     * allows read access to the special 'null entity' containing
     * default values.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool om_access_to_null_entity;

    /**
     * Allow or disallow modification of attributes
     *
     * Only in effect if constexpr om_verify_attribute_modification is true.
     * If in effect, will raise runtime exception on attempt to modify
     * an attribute in an event time function.
     * Turned on or off to permit or deny attribute modification 
     * in event lifecycle code.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool om_permit_attribute_modification;

    /**
     * Allow or disallow access to time-like attributes
     *
     * Only in effect if constexpr om_verify_ timelike_attribute_access is true.
     * If in effect, will raise runtime exception on attempt to access
     * a time-like attribute in an event time function.
     * Turned on or off to permit or deny access to time-like attribute
     * in event lifecycle code.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool om_permit_timelike_attribute_access;

    /**
     * Turn on or off event trace from model code.
     * Accessed through API StartEventTrace and StopEventTrace.
     * Has no effect if constexpr om_event_trace_capable is false.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool event_trace_on;

    /**
     * Values that represent the type of event trace message
     */
    enum class et_msg_type {

        // event occurrence
        eEventOccurrence,

        // self-scheduling event occurrence
        eSelfSchedulingEventOccurrence,

        // queued event
        eQueuedEvent,

        // queued self-scheduling event
        eQueuedSelfSchedulingEvent,

        // enter simulation
        eEnterSimulation,

        // enter simulation
        eExitSimulation,

        // starting attribute value
        eAttributeStart,

        // change of attribute value
        eAttributeChange,

        // starting link attribute value
        eLinkAttributeStart,

        // change of link attribute value
        eLinkAttributeChange,

        // starting multilink value
        eMultilinkStart,

        // change in multilink - insert entity 
        eMultilinkInsert,

        // change in multilink - erase entity 
        eMultilinkErase,
    };

    /**
     * Values that represent the report style of event trace messages
     */
    enum class et_report_style {

        // like Modgen
        eModgen,

        // designed for reading
        eReadable
    };

    /**
     * The report style for event trace
     */
    static enum et_report_style event_trace_report_style;

    /**
     * Whether to show normal events in the event trace
     */
    static bool event_trace_show_events;

    /**
     * Whether to show queued normal events in the event trace
     */
    static bool event_trace_show_queued_events;

    /**
     * Whether to show queued self-scheduling events in the event trace
     */
    static bool event_trace_show_queued_self_scheduling_events;

    /**
     * Whether to suppress queued events with unchanged time-to-event in the event trace
     */
    static bool event_trace_show_queued_just_changes;

    /**
     * Whether to show enter simulation information in the event trace
     */
    static bool event_trace_show_enter_simulation;

    /**
     * Whether to show exit simulation information in the event trace
     */
    static bool event_trace_show_exit_simulation;

    /**
     * Whether to show self-scheduling events in the event trace
     */
    static bool event_trace_show_self_scheduling_events;

    /**
     * Whether to show changes in attributes
     */
    static bool event_trace_show_attributes;

    /**
     * Filter event trace by time (lower bound)
     */
    static double event_trace_minimum_time;

    /**
     * Filter event trace by time (upper bound)
     */
    static double event_trace_maximum_time;

    /**
     * Filter event trace by age (lower bound)
     */
    static double event_trace_minimum_age;

    /**
     * Filter event trace by age (upper bound)
     */
    static double event_trace_maximum_age;

    /**
     * Filter event trace by entities
     */
    static std::unordered_set<int> event_trace_selected_entities;

    /**
     * Whether to show linked entities
     */
    static bool event_trace_show_linked_entities;

    /**
     * Filter event trace by events
     */
    static std::unordered_set<int> event_trace_selected_events;

    /**
     * Filter event trace by attributes
     */
    static std::unordered_set<int> event_trace_selected_attributes;

    /**
     * Whether to select all attributes
     */
    static bool event_trace_select_all_attributes;

    /**
     * Used to set report column width for names
     */
    static int event_trace_name_column_width;

    /**
     * Used to control maximum number of output lines in event trace
     */
    static int event_trace_maximum_lines;

    /**
     * @fn  static void BaseEntity::event_trace_msg( const char* entity_name, int entity_id, double entity_age, double case_seed, const char* cstr1, int other_id, const char* cstr2, double dbl1, double dbl2, double global_time, et_msg_type msg_type)
     *
     * @brief   Format an event trace message and output it to the trace.
     *          
     *          This function is used in code generated by omc.
     *
     * @param   entity_name If non-null, name of the entity.
     * @param   entity_id   Identifier for the entity.
     * @param   entity_age  The entity age.
     * @param   case_seed   The case seed.
     * @param   cstr1       If non-null, name of the event.
     * @param   other_id    The time.
     * @param   cstr2       The second cstr.
     * @param   dbl1        The 1.
     * @param   dbl2        The 2.
     * @param   global_time The global time.
     * @param   msg_type    Type of the message.
     */
    static void event_trace_msg(
        const char* entity_name,
        int entity_id,
        double entity_age,
        double case_seed,
        const char* cstr1,
        int other_id,
        const char* cstr2,
        double dbl1,
        double dbl2,
        double global_time,
        et_msg_type msg_type)
    {
        // Apply maximum line limit independent of report style
        if (event_trace_maximum_lines <= 0) {
            // Maximum line count exceeded
            if (event_trace_maximum_lines == 0) {
                theTrace->logFormatted(LT("Maximum lines exceeded, increase using EventTrace.MaximumLines"));
                event_trace_maximum_lines = -1;
            }
            return;
        }

        // Apply event trace filter conditions (but not if modgen-style)
        if (event_trace_report_style == et_report_style::eReadable) {
            if (global_time < event_trace_minimum_time) {
                // Message occurs before the specified time window.
                return;
            }
            if (global_time > event_trace_maximum_time) {
                // Message occurs after the specified time window.
                return;
            }
            if (entity_age < event_trace_minimum_age) {
                // Message occurs before the specified age window.
                return;
            }
            if (entity_age > event_trace_maximum_age) {
                // Message occurs after the specified age window.
                return;
            }
            if (msg_type == et_msg_type::eEnterSimulation && !event_trace_show_enter_simulation) {
                // Entity enter simulation messages are disabled.
                return;
            }
            if (msg_type == et_msg_type::eExitSimulation && !event_trace_show_exit_simulation) {
                // Entity exit simulation messages are disabled.
                return;
            }
            if (msg_type == et_msg_type::eEventOccurrence && !event_trace_show_events) {
                // Event occurrence messages are disabled.
                return;
            }
            if (msg_type == et_msg_type::eSelfSchedulingEventOccurrence && !event_trace_show_self_scheduling_events) {
                // Self-scheduling events are disabled.
                return;
            }
            if (msg_type == et_msg_type::eAttributeChange && (!event_trace_show_attributes || event_trace_selected_attributes.size() == 0)) {
                // Attribute changes are disabled, or no attributes selected.
                return;
            }
            if (event_trace_selected_entities.size() > 0 && event_trace_selected_entities.count(entity_id) == 0) {
                // Entity is not in the specified entity list.
                return;
            }
            if ((msg_type == et_msg_type::eEventOccurrence || msg_type == et_msg_type::eQueuedEvent) && event_trace_selected_events.size() > 0 && event_trace_selected_events.count(other_id) == 0) {
                // Event is not in the specified event list.
                return;
            }
            if (msg_type == et_msg_type::eQueuedEvent && !event_trace_show_queued_events) {
                // Queued normal events are disabled.
                return;
            }
            if (msg_type == et_msg_type::eQueuedSelfSchedulingEvent && !event_trace_show_queued_self_scheduling_events) {
                // Queued self-scheduling events are disabled.
                return;
            }
            if ((
                   msg_type == et_msg_type::eAttributeStart
                || msg_type == et_msg_type::eAttributeChange
                || msg_type == et_msg_type::eLinkAttributeStart
                || msg_type == et_msg_type::eLinkAttributeChange
                || msg_type == et_msg_type::eMultilinkStart
                || msg_type == et_msg_type::eMultilinkInsert
                || msg_type == et_msg_type::eMultilinkErase
                ) && !(event_trace_select_all_attributes || event_trace_selected_attributes.count(other_id) != 0)) {
                // Attribute or multilink is not in the selected attributes list.
                return;
            }
        }

        switch (event_trace_report_style) {
        case et_report_style::eModgen:
        {
            switch (msg_type) {
            case et_msg_type::eEventOccurrence:
            case et_msg_type::eQueuedEvent:
            case et_msg_type::eSelfSchedulingEventOccurrence:
            {
                // decrement the count af remaining lines before maximum reached
                event_trace_maximum_lines--;

                auto& the_time = dbl1;
                auto& the_name = cstr2;
                theTrace->logFormatted("%s - actor_id=%d - case_seed=%.0f -  : event=%s - time=%.15f",
                    entity_name,
                    entity_id,
                    case_seed,
                    the_name,
                    the_time);
            }
            break;
            // ignore all other message types for modgen style output
            default:
                break;
            }
        }
        break;
        case et_report_style::eReadable:
            {
                // target width of name column in report
                const int name_colwidth = BaseEntity::event_trace_name_column_width;

                // width of 'what' column
                const int what_width = 11;

                // column headers
                static bool header_done = false;
                if (!header_done) {
                    header_done = true;
                    theTrace->logFormatted(
                        "%13s %8.8s %10s %8s %-*s %13s %-*s %s",
                        "Time",
                        "Entity",
                        "Age",
                        "Id",
                        what_width,
                        "Trace",
                        "Value",
                        name_colwidth,
                        "Name",
                        "    Remarks"
                    );
                    event_trace_maximum_lines--;
                }

                // decrement the count of remaining lines before maximum reached
                event_trace_maximum_lines--;

                // style is similar to that produced by test_models
                // using normalize_event_trace in common.pm
                
                switch (msg_type) {
                case et_msg_type::eEventOccurrence:
                {
                    auto what = "  EVENT";
                    auto& event_name = cstr1;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        "",
                        name_colwidth,
                        event_name
                    );
                }
                break;
                case et_msg_type::eSelfSchedulingEventOccurrence:
                {
                    auto what = "  EVENT";
                    auto& event_name = cstr1;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        "", // no Value
                        name_colwidth,
                        event_name // is pretty name, eg trigger_changes(calendar_year)
                    );
                }
                break;
                case et_msg_type::eQueuedEvent:
                {
                    auto what = "    queued";
                    auto& new_time = dbl1;
                    auto& old_time = dbl2;
                    auto& timefn_name = cstr2; // name of event time function, eg timeMigrationEvent
                    if (event_trace_show_queued_just_changes && (new_time == old_time)) {
                        // Do not report if time-to-event did not change.
                        break;
                    }
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.6f     %-*s was %.6f",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        new_time,
                        name_colwidth,
                        timefn_name,
                        old_time
                    );
                }
                break;
                case et_msg_type::eQueuedSelfSchedulingEvent:
                {
                    auto what = "    queued";
                    auto& new_time = dbl1;
                    auto& event_name = cstr1;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.6f     %-*s",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        new_time,
                        name_colwidth,
                        event_name // is pretty name, eg trigger_changes(calendar_year)
                    );
                }
                break;
                case et_msg_type::eEnterSimulation:
                {
                    auto what = "ENTER";
                    auto& entity_time = dbl1;
                    auto& description  = cstr2; // is "enter_simulation"
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s     initial time=%.6f,age=%.6f",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        "==========", // no Value
                        name_colwidth,
                        "==========",
                        entity_time,
                        entity_age
                    );
                }
                break;
                case et_msg_type::eExitSimulation:
                {
                    auto what = "EXIT";
                    auto& entity_time = dbl1;
                    auto& description = cstr2; // is "exit_simulation"
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        "==========", // no Value
                        name_colwidth,
                        "==========" // no Name
                    );
                }
                break;
                case et_msg_type::eAttributeStart:
                {
                    auto what = "    attr";
                    auto& start_value = dbl1;
                    auto& attribute_name = cstr2;   // name of attribute eg 'year'
                    std::stringstream ss;
                    ss << std::setw(9) << std::setprecision(4) << start_value;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.13g   %-*s   initial",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        start_value,
                        name_colwidth,
                        attribute_name
                    );
                }
                break;
                case et_msg_type::eAttributeChange:
                {
                    auto what = "    attr";
                    auto& old_value = dbl1;
                    auto& new_value = dbl2;
                    auto& attribute_name = cstr2;   // name of attribute eg 'year'
                    std::stringstream ss;
                    ss << std::setw(9) << std::setprecision(4) << new_value;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.13g   %-*s   was %.13g",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        //ss.str().c_str(),
                        new_value,
                        name_colwidth,
                        attribute_name,  // is name of attribute eg year
                        old_value
                    );
                }
                break;
                case et_msg_type::eLinkAttributeStart:
                {
                    auto what = "    link";
                    auto& start_value = dbl1;
                    auto& attribute_name = cstr2;   // name of link attribute eg 'lSpouse'
                    std::stringstream ss;
                    if (start_value >= 0) {
                        // starting link value is the entity_id of the entity
                        ss << (int)start_value;
                    }
                    else {
                        // starting link value is nullptr
                        ss << "nullptr";
                    }
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s   %-*s   initial",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        ss.str().c_str(),
                        name_colwidth,
                        attribute_name
                    );
                }
                break;
                case et_msg_type::eLinkAttributeChange:
                {
                    auto what = "    link";
                    auto& old_value = dbl1;
                    auto& new_value = dbl2;
                    auto& attribute_name = cstr2;   // name of link attribute eg 'lSpouse'
                    std::stringstream ss_new;
                    if (new_value >= 0) {
                        // new link value is the entity_id of the entity
                        ss_new << (int)new_value;
                    }
                    else {
                        // new link value is nullptr
                        ss_new << "nullptr";
                    }
                    std::stringstream ss_old;
                    if (old_value >= 0) {
                        // old link value is the entity_id of the entity
                        ss_old << (int)old_value;
                    }
                    else {
                        // old link value is nullptr
                        ss_old << "nullptr";
                    }
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s   %-*s   was %s",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        ss_new.str().c_str(),
                        name_colwidth,
                        attribute_name,
                        ss_old.str().c_str()
                    );
                }
                break;
                case et_msg_type::eMultilinkStart:
                {
                    auto what = "    multi";
                    auto& multilink_name = cstr2;   // name of the multilink, eg 'mlChildren'
                    auto& contents = cstr1; // comma-separated list of entity_id's
                    std::stringstream ss;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s   %-*s   initial {%s}",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        "", // no Value
                        name_colwidth,
                        multilink_name,
                        contents
                    );
                }
                break;
                case et_msg_type::eMultilinkInsert:
                {
                    auto what = "    multi++";
                    int ent_id = (int)dbl1;
                    auto& contents = cstr1; // comma-separated list of entity_id's
                    auto& multilink_name = cstr2;   // name of the multilink, eg 'mlChildren'
                    std::stringstream ss;
                    ss << ent_id;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13d   %-*s   is {%s}",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        //ss.str().c_str(),
                        ent_id,
                        name_colwidth,
                        multilink_name,
                        contents
                    );
                }
                break;
                case et_msg_type::eMultilinkErase:
                {
                    auto what = "    multi--";
                    int ent_id = (int)dbl1;
                    auto& contents = cstr1; // comma-separated list of entity_id's
                    auto& multilink_name = cstr2;   // name of the multilink, eg 'mlChildren'
                    std::stringstream ss;
                    ss << ent_id;
                    theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13d   %-*s   is {%s}",
                        global_time,
                        entity_name,
                        entity_age,
                        entity_id,
                        what_width,
                        what,
                        //ss.str().c_str(),
                        ent_id,
                        name_colwidth,
                        multilink_name,
                        contents
                    );
                }
                break;
                default:
                    {
                        assert(false);
                    }
                } // switch (msg_type)
            }
            break;
        default:
            {
                assert(false);
            }
        } // switch (event_trace_report_style)
    }

    /**
     * Initializes run-time before simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of entity has
     * associated objects.
     */
    static void initialize_simulation_runtime();

    /**
     * Cleans up run-time after simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of entity has
     * associated objects.
     */
    static void finalize_simulation_runtime();

private:

    /**
     * The iterator of this entity in BaseEntity::entities.
     */
    std::list<BaseEntity *>::iterator iter_in_entities;

    /**
     * Active entities (polymorphic)
     */
    static thread_local std::list<BaseEntity *> *entities;
};

/**
 * Entity. Only instances of derived classes of Entity are actually created.
 *
 * @tparam A Type of a.
 */
template<typename E>
class Entity : public BaseEntity
{
public:

    /**
     * Entity allocation operator. This allocator recycles entities of the given type. Note that the
     * argument of new() is required for the correct signature but is not used.
     *
     * @param count Size of object (required for correct signature)
     *
     * @return The allocated object.
     */
    void *operator new( size_t count )
    {
		E *entity = nullptr;
        if constexpr (om_resource_use_on) {
            ++activation_count;
        }
        assert(available);
        if ( available->empty() ) {
			entity = ::new E;
            if constexpr (om_resource_use_on) {
                ++allocation_count;
            }
        }
        else {
            entity = available->front();
            available->pop_front();
        }

        return entity;
    }

    void make_zombie()
    {
        assert(zombies);
        zombies->push_front( (E *)this );
    }

    /**
     * Free zombies. Move all zombie entities to the available list for re-use.
     */
    static void free_zombies()
    {
        assert(zombies);
        assert(available);
        while ( ! zombies->empty() ) {
            available->push_front( zombies->front() );
            zombies->pop_front();
        }
    }

    /**
     * Free available list and release associated memory.
     */
    static void free_available()
    {
        assert(available);
        while (!available->empty()) {
            delete *available->front();
            available->pop_front();
        }
    }

    /**
     * Resource use information for the entity
     */
    static auto resource_use()
    {
        struct result { size_t allocations; size_t activations; };
        return result { allocation_count, activation_count };
    }

    /**
     * Reset resource use information for the entity
     */
    static void resource_use_reset()
    {
        allocation_count = 0;
        activation_count = 0;
    }

    static thread_local std::forward_list<E *> *zombies;
    static thread_local std::forward_list<E *> *available;

    /**
    * Count of allocations
    *
    * The number of allocations from c++ memory allocator.
    * Note that because of re-use, this is not necessarily the same as the number of
    * invocations of 'new' in model code.
    */
    static thread_local std::size_t allocation_count;

    /**
    * Count of activations
    * 
    * The number invocations of 'new' in model code.
    * This is not necessarily the same as the number of allocations from c++ memory allocator.
    */
    static thread_local std::size_t activation_count;
};


/**
* Entity zombie list (definition)
*/

template<typename E>
thread_local std::forward_list<E *> *Entity<E>::zombies;

/**
* Entity available list (definition)
*/

template<typename E>
thread_local std::forward_list<E *> *Entity<E>::available;

template<typename E>
thread_local std::size_t Entity<E>::allocation_count = 0;

template<typename E>
thread_local std::size_t Entity<E>::activation_count = 0;

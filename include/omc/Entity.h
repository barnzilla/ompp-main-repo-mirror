/**
 * @file    Entity.h
 * Declares the Agent class and associated classes and templates
 *         
 */
// Copyright (c) 2013-2021 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

#pragma once
#include <list>
#include <forward_list>
#include <unordered_set>
#include <sstream>
#include <cassert>
#include "libopenm/omModel.h" // for theTrace
#include "globals0.h" // for ModelExit
#include "om_types0.h" // for Time

/**
 * Base agent.
 */
class BaseEntity
{
public:
    /**
     * Explicitly declared virtual destructor
     * to allow safe delete of isntances of derived classes.
     */
    virtual ~BaseEntity() = default;

    /**
     * Assign initial value to all data members in agent, with no side-effects. The function
     * definition is specific to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_data_members() = 0;

    /**
     * Get entity name
     */
    virtual const char * om_get_entity_name() = 0;

    /**
     * Assign unique entity_id to entity as part of initialization.
     */
    virtual void om_set_entity_id() = 0;

    /**
     * Get unique entity_id of agent.
     */
    virtual int om_get_entity_id() = 0;

    /**
     * Get current time of agent.
     */
    virtual Time om_get_time() = 0;

    /**
     * Get current age of agent.
     */
    virtual Time om_get_age() = 0;

    /**
     * Initialize time and age as part of entity initialization.
     */
    virtual void om_initialize_time_and_age() = 0;

    /**
     * Assign offset of each attribute and increment in the entity.
     * 
     * This function is called exactly once for each kind of entity to assign static members which
     * contain the offset of each attribute within the containing entity. This offset is used to
     * access the containing entity to invoke side-effects when the value of the attribute changes.
     * These offsets are fixed at compile time but the value cannot cannot be determined by the C++
     * compiler at the time of template instantiation.
     */
    virtual void om_assign_member_offsets() = 0;

    /**
     * Insert agent into entity sets of this agent type. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_entity_sets() = 0;

    /**
     * Initialize value_in values for agentvars used in tables. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_tables() = 0;

    /**
     * Compute occurrence time for each event in agent. The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_events() = 0;

    /**
     * Remove agent from entity sets of this agent type. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_entity_sets() = 0;

    /**
     * Complete all pending table updates. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_tables() = 0;

    /**
     * Initialize identity attributes by evaluating their associated expressions.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_identity_attributes() = 0;

    /**
     * Initialize derived attributes by evaluating injected code.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_derived_attributes() = 0;

    /**
     * Check that starting value of time is valid and raise run-time error if not.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_check_starting_time() = 0;

    /**
     * Reset derived attributes by evaluating injected code.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_reset_derived_attributes() = 0;

    /**
     * Finalize agent events (remove from event queue). The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_finalize_events() = 0;

    /**
     * Sets all links in the agent to nullptr when the agent leaves the simulation.
     */
    virtual void om_finalize_links() = 0;

    /**
     * Empties all multilinks in the agent when the agent leaves the simulation.
     */
    virtual void om_finalize_multilinks() = 0;

    /**
     * Age the agent to the given time.
     *
     * @param t The target time.
     */
    virtual void age_agent( Time t ) = 0;

    /**
     * Add the agent to the zombie list for agents of this type.
     */
    virtual void make_zombie() = 0;

    /**
     * Age all entities to the given time.
     * 
     * If originating_entity_id is not supplied, no check for time running backwards is performed
     * 
     * @param t                     The target time.
     * @param originating_entity_id Identifier of the entity within which the event occurred.
     */
    static void age_all_agents( Time t, int originating_entity_id = -1, int originating_event_id = -1)
    {
        assert(agents);
        for ( auto agent : *agents ) {
            if (agent->om_get_entity_id() == originating_entity_id) {
                // This is the entity within which the event occurred.
                // Check for time running backwards in the entity within which the event occurred
                if (t < agent->om_get_time()) {
                    // The time of this event is in the local past of the entity within which the event occurs.
                    // This is an error in model logic.
                    // Write log message and throw run-time exception.
                    handle_backwards_time(
                        t,
                        agent->om_get_time(),
                        originating_event_id,
                        originating_entity_id
                    );
                }
            }
            agent->age_agent( t );
        }
        // Note that global time is updated in framework module
        // by calling BaseEvent::set_global_time(t);
    }

    /**
     * Move all agents from zombie lists to corresponding available list.
     * 
     * The function definition is generated by the openM++ compiler.
     */
    static void free_all_zombies();

    /**
     * Adds the agent to the list of active agents.
     */
    void make_active()
    {
        assert(agents);
        agents->push_front( this );
        iter_in_agents = agents->begin();
    }

    /**
     * Removes the agent from the list of active agents.
     */    
    void make_inactive()
    {
        assert(agents);
        agents->erase( iter_in_agents );
    }

    /**
     * Initialize all attributes of the entity.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the beginning of a member function named Start().
     */
    void initialize_attributes()
    {
        om_active = false;
        om_initialize_data_members();
        om_set_entity_id();
        om_initialize_time_and_age();
        om_initialize_derived_attributes();
        om_initialize_identity_attributes();
    }

    /**
     * Have the entity enter the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the end of a member function named Start().
     */
    void enter_simulation()
    {
        if (om_event_trace_capable) { // is constexpr
            extern double GetCaseSeed();
            if (event_trace_on) {
                event_trace_msg(
                    om_get_entity_name(),
                    (int)om_get_entity_id(),
                    GetCaseSeed(),
                    "", // no associated event
                    -1, // no associated event
                    "enter_simulation",
                    om_get_time(), // the value of time in the entity before it enters the simulation
                    get_global_time(), 
                    et_msg_type::eEnterSimulation
                );
            }
        }
        om_check_starting_time();
        om_reset_derived_attributes();
        om_initialize_identity_attributes();
        om_initialize_entity_sets();
        om_initialize_tables();
        om_initialize_events();
        make_active();
        om_active = true;
    }

    /**
     * Have the entity exit the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle.
     */
    void exit_simulation()
    {
        if (om_event_trace_capable) { // is constexpr
            extern double GetCaseSeed();
            if (event_trace_on) {
                event_trace_msg(
                    om_get_entity_name(),
                    (int)om_get_entity_id(),
                    GetCaseSeed(),
                    "", // no associated event
                    -1, // no associated event
                    "exit_simulation",
                    om_get_time(), // the value of time in the entity when it exits the simulation
                    get_global_time(),
                    et_msg_type::eExitSimulation
                );
            }
        }
        om_finalize_entity_sets();
        om_finalize_tables();
        om_finalize_events();
        om_active = false;
        om_finalize_links();
        om_finalize_multilinks();
        make_inactive();
        make_zombie();
    }

    /**
     * Have all entities exit the simulation.
     * 
     * Can be called by framework model code as part of the simulation or case lifecycle.
     */
    static void exit_simulation_all()
    {
        // Iteration over agents needs to be robust to deletion of current iterator.
        assert(agents);
        auto it = agents->begin();
        while (it != agents->end()) {
            auto agent = *it;
            ++it; // increment iterator before erasing it from agents
            agent->exit_simulation();
        }
    }

    /**
     * Number of active agents.
     *
     * @return An int.
     */
    static int om_active_agents()
    {
        assert(agents);
        return agents->size();
    }

    /**
     * True if agent is active in the simulation.
     */
    bool om_active;

    /**
     * Turn on or off event trace from model code.
     * Accessed through API StartEventTrace and StopEventTrace.
     * Has no effect if constexpr om_event_trace_capable is false.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool event_trace_on;

    /**
     * Values that represent the type of event trace message
     */
    enum class et_msg_type {

        // event occurrence
        eEventOccurrence,

        // self-scheduling event occurrence
        eSelfSchedulingEventOccurrence,

        // queued event
        eQueuedEvent,

        // queued self-scheduling event
        eQueuedSelfSchedulingEvent,

        // enter simulation
        eEnterSimulation,

        // enter simulation
        eExitSimulation,
    };

    /**
     * Values that represent the report style of event trace messages
     */
    enum class et_report_style {

        // like Modgen
        eModgen,

        // designed for reading
        eReadable
    };

    /**
     * The report style for event trace
     *
     * Defined by C++ code generated by omc.
     */
    static enum et_report_style event_trace_report_style;

    /**
     * Whether to show queued normal events in the event trace
     *
     * Defined by C++ code generated by omc.
     */
    static bool event_trace_show_queued_events;

    /**
     * Whether to show queued self-scheduling events in the event trace
     *
     * Defined by C++ code generated by omc.
     */
    static bool event_trace_show_queued_self_scheduling_events;

    /**
     * Whether to show enter simulation information in the event trace
     *
     * Defined by C++ code generated by omc.
     */
    static bool event_trace_show_enter_simulation;

    /**
     * Whether to show exit simulation information in the event trace
     *
     * Defined by C++ code generated by omc.
     */
    static bool event_trace_show_exit_simulation;

    /**
     * Whether to show self-scheduling events in the event trace
     *
     * Defined by C++ code generated by omc.
     */
    static bool event_trace_show_self_scheduling_events;

    /**
     * Filter event trace by time (lower bound)
     *
     * Defined by C++ code generated by omc.
     */
    static double event_trace_minimum_time;

    /**
     * Filter event trace by time (upper bound)
     *
     * Defined by C++ code generated by omc.
     */
    static double event_trace_maximum_time;

    /**
     * Filter event trace by entities
     *
     * Defined by C++ code generated by omc.
     */
    static std::unordered_set<int> event_trace_selected_entities;

    /**
     * Used to filter event trace by events
     *
     * Defined by C++ code generated by omc.
     */
    static std::unordered_set<int> event_trace_selected_events;

    /**
     * Format an event trace message and output it to the trace.
     *
     * This function is used in code generated by omc.
     *
     * @param entity_name If non-null, name of the entity.
     * @param entity_id   Identifier for the entity.
     * @param case_seed   The case seed.
     * @param event_name  If non-null, name of the event.
     * @param time        The time.
     */
    static void event_trace_msg(
        const char* entity_name,
        int entity_id,
        double case_seed,
        const char* event_name,
        int event_id,
        const char *event_description,
        double reported_time,
        double global_time,
        et_msg_type msg_type)
    {
        // Apply event trace filter conditions
        if (global_time < event_trace_minimum_time) {
            // Message occurs before the specified time window.
            return;
        }
        if (global_time > event_trace_maximum_time) {
            // Message occurs after the specified time window.
            return;
        }
        if (msg_type == et_msg_type::eEnterSimulation && !event_trace_show_enter_simulation) {
            // Entity enter simulation messages are disabled.
            return;
        }
        if (msg_type == et_msg_type::eExitSimulation && !event_trace_show_exit_simulation) {
            // Entity exit simulation messages are disabled.
            return;
        }
        if (msg_type == et_msg_type::eSelfSchedulingEventOccurrence && !event_trace_show_self_scheduling_events) {
            // Self-scheduling events are disabled.
            return;
        }
        if (event_trace_selected_entities.size() > 0 && event_trace_selected_entities.count(entity_id) == 0) {
            // Entity is not in the specified entity list.
            return;
        }
        if ((msg_type == et_msg_type::eEventOccurrence || msg_type == et_msg_type::eQueuedEvent) && event_trace_selected_events.size() > 0 && event_trace_selected_events.count(event_id) == 0) {
            // Event is not in the specified event list.
            return;
        }
        if (msg_type == et_msg_type::eQueuedEvent && !event_trace_show_queued_events) {
            // Queued normal events are disabled.
            return;
        }
        if (msg_type == et_msg_type::eQueuedSelfSchedulingEvent && !event_trace_show_queued_self_scheduling_events) {
            // Queued self-scheduling events are disabled.
            return;
        }

        switch (event_trace_report_style) {
        case et_report_style::eModgen:
        {
            switch (msg_type) {
            case et_msg_type::eEventOccurrence:
            case et_msg_type::eQueuedEvent:
            {
                theTrace->logFormatted("%s - actor_id=%d - case_seed=%.0f -  : event=%s - time=%.15f",
                    entity_name,
                    entity_id,
                    case_seed,
                    event_description,
                    reported_time);
            }
            break;
            // ignore all other message types for modgen style output
            default:
                break;
            }
        }
        break;
        case et_report_style::eReadable:
            {
                // style is similar to that produced by test_models
                // using normalize_event_trace in common.pm
                switch (msg_type) {
                case et_msg_type::eEventOccurrence:
                {
                    assert(global_time == reported_time);
                    theTrace->logFormatted("%13.6f   EVENT ********* %08d %s (age=%.6f)",
                        global_time,
                        entity_id,
                        event_description,
                        reported_time
                    );
                }
                break;
                case et_msg_type::eSelfSchedulingEventOccurrence:
                {
                    assert(global_time == reported_time);
                    theTrace->logFormatted("%13.6f   EVENT(SS) ***** %08d %s.%s (age=%.6f)",
                        global_time,
                        entity_id,
                        entity_name,
                        event_name,
                        reported_time
                    );
                }
                break;
                case et_msg_type::eQueuedEvent:
                {
                    theTrace->logFormatted("%13.6f     %13.6f %08d     %s.%s",
                        global_time,
                        reported_time,
                        entity_id,
                        entity_name,
                        event_description // name of time function, eg timeMigrationEvent
                    );
                }
                break;
                case et_msg_type::eQueuedSelfSchedulingEvent:
                {
                    theTrace->logFormatted("%13.6f     %13.6f %08d     %s.%s",
                        global_time,
                        reported_time,
                        entity_id,
                        entity_name,
                        event_name // pretty name, eg trigger_changes(calendar_year)
                    );
                }
                break;
                case et_msg_type::eEnterSimulation:
                {
                    theTrace->logFormatted("%13.6f  ENTER SIMULATION %08d %s.%s (initial time=%.6f)",
                        global_time,
                        entity_id,
                        entity_name,
                        event_description,
                        reported_time
                    );
                }
                break;
                case et_msg_type::eExitSimulation:
                {
                    theTrace->logFormatted("%13.6f  EXIT SIMULATION  %08d %s.%s (entity time=%.6f)",
                        global_time,
                        entity_id,
                        entity_name,
                        event_description,
                        reported_time
                    );
                }
                break;
                default:
                    {
                        assert(false);
                    }
                } // switch (msg_type)
            }
            break;
        default:
            {
                assert(false);
            }
        } // switch (event_trace_report_style)
    }

    /**
     * Initializes run-time before simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of agent has
     * associated objects.
     */
    static void initialize_simulation_runtime();

    /**
     * Cleans up run-time after simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of agent has
     * associated objects.
     */
    static void finalize_simulation_runtime();

private:

    /**
     * The iterator of this agent in BaseEntity::agents.
     */
    std::list<BaseEntity *>::iterator iter_in_agents;

    /**
     * Active agents.
     */
    static thread_local std::list<BaseEntity *> *agents;
};

/**
 * Entity. Only instances of derived classes of Entity are actually created.
 *
 * @tparam A Type of a.
 */
template<typename E>
class Entity : public BaseEntity
{
public:

    /**
     * Entity allocation operator. This allocator recycles entities of the given type. Note that the
     * argument of new() is required for the correct signature but is not required or used.
     *
     * @param count Size of object (required for correct signature)
     *
     * @return The allocated object.
     */
    void *operator new( size_t count )
    {
		E *entity = nullptr;
        assert(available);
        if ( available->empty() ) {
			entity = ::new E;
        }
        else {
            entity = available->front();
            available->pop_front();
        }

        return entity;
    }

    void make_zombie()
    {
        assert(zombies);
        zombies->push_front( (E *)this );
    }

    /**
     * Free zombies. Move all zombie agents to the available list for re-use.
     */
    static void free_zombies()
    {
        assert(zombies);
        assert(available);
        while ( ! zombies->empty() ) {
            available->push_front( zombies->front() );
            zombies->pop_front();
        }
    }

    static thread_local std::forward_list<E *> *zombies;
    static thread_local std::forward_list<E *> *available;

};


/**
* Agent zombie list (definition)
*/

template<typename E>
thread_local std::forward_list<E *> *Entity<E>::zombies;

/**
* Agent available list (definition)
*/

template<typename E>
thread_local std::forward_list<E *> *Entity<E>::available;


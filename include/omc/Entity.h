/**
 * @file    Entity.h
 * Declares the Agent class and associated classes and templates
 *         
 */
// Copyright (c) 2013-2021 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

#pragma once
#include <list>
#include <forward_list>
#include <unordered_set>
#include <sstream>
#include <cassert>
#include "libopenm/omModel.h" // for theTrace
#include "globals0.h" // for ModelExit
#include "om_types0.h" // for Time

/**
 * Base agent.
 */
class BaseEntity
{
public:
    /**
     * Explicitly declared virtual destructor
     * to allow safe delete of isntances of derived classes.
     */
    virtual ~BaseEntity() = default;

    /**
     * Assign initial value to all data members in agent, with no side-effects. The function
     * definition is specific to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_data_members() = 0;

    /**
     * Assign unique entity_id to agent as part of initialization.
     */
    virtual void om_set_entity_id() = 0;

    /**
     * Get unique entity_id of agent.
     */
    virtual int om_get_entity_id() = 0;

    /**
     * Get current time of agent.
     */
    virtual Time om_get_time() = 0;

    /**
     * Initialize time and age as part of entity initialization.
     */
    virtual void om_initialize_time_and_age() = 0;

    /**
     * Assign offset of each attribute and increment in the entity.
     * 
     * This function is called exactly once for each kind of entity to assign static members which
     * contain the offset of each attribute within the containing entity. This offset is used to
     * access the containing entity to invoke side-effects when the value of the attribute changes.
     * These offsets are fixed at compile time but the value cannot cannot be determined by the C++
     * compiler at the time of template instantiation.
     */
    virtual void om_assign_member_offsets() = 0;

    /**
     * Insert agent into entity sets of this agent type. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_entity_sets() = 0;

    /**
     * Initialize value_in values for agentvars used in tables. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_tables() = 0;

    /**
     * Compute occurrence time for each event in agent. The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_events() = 0;

    /**
     * Remove agent from entity sets of this agent type. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_entity_sets() = 0;

    /**
     * Complete all pending table updates. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_tables() = 0;

    /**
     * Initialize identity attributes by evaluating their associated expressions.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_identity_attributes() = 0;

    /**
     * Initialize derived attributes by evaluating injected code.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_derived_attributes() = 0;

    /**
     * Check that starting value of time is valid and raise run-time error if not.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_check_starting_time() = 0;

    /**
     * Reset derived attributes by evaluating injected code.
     * The function definition is specific to each kind of agent and is generated by the openM++
     * compiler.
     */
    virtual void om_reset_derived_attributes() = 0;

    /**
     * Finalize agent events (remove from event queue). The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_finalize_events() = 0;

    /**
     * Sets all links in the agent to nullptr when the agent leaves the simulation.
     */
    virtual void om_finalize_links() = 0;

    /**
     * Empties all multilinks in the agent when the agent leaves the simulation.
     */
    virtual void om_finalize_multilinks() = 0;

    /**
     * Age the agent to the given time.
     *
     * @param t The target time.
     */
    virtual void age_agent( Time t ) = 0;

    /**
     * Add the agent to the zombie list for agents of this type.
     */
    virtual void make_zombie() = 0;

    /**
     * Age all agents to the given time.
     * 
     * If originating_entity_id is not supplied, no check for time running backwards is performed
     * 
     * @param t                     The target time.
     * @param originating_entity_id Identifier of the entity within which the event occurred.
     */
    static void age_all_agents( Time t, int originating_entity_id = -1, int originating_event_id = -1)
    {
        assert(agents);
        for ( auto agent : *agents ) {
            if (agent->om_get_entity_id() == originating_entity_id) {
                // This is the entity within which the event occurred.
                // Check for time running backwards in the entity within which the event occurred
                if (t < agent->om_get_time()) {
                    // The time of this event is in the local past of the entity within which the event occurs.
                    // This is an error in model logic.
                    // Write log message and throw run-time exception.
                    handle_backwards_time(
                        t,
                        agent->om_get_time(),
                        originating_event_id,
                        originating_entity_id
                    );
                }
            }
            agent->age_agent( t );
        }
    }

    /**
     * Move all agents from zombie lists to corresponding available list.
     * 
     * The function definition is generated by the openM++ compiler.
     */
    static void free_all_zombies();

    /**
     * Adds the agent to the list of active agents.
     */
    void make_active()
    {
        assert(agents);
        agents->push_front( this );
        iter_in_agents = agents->begin();
    }

    /**
     * Removes the agent from the list of active agents.
     */    
    void make_inactive()
    {
        assert(agents);
        agents->erase( iter_in_agents );
    }

    /**
     * Initialize all attributes of the entity.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the beginning of a member function named Start().
     */
    void initialize_attributes()
    {
        om_active = false;
        om_initialize_data_members();
        om_set_entity_id();
        om_initialize_time_and_age();
        om_initialize_derived_attributes();
        om_initialize_identity_attributes();
    }

    /**
     * Have the entity enter the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the end of a member function named Start().
     */
    void enter_simulation()
    {
        om_check_starting_time();
        om_reset_derived_attributes();
        om_initialize_identity_attributes();
        om_initialize_entity_sets();
        om_initialize_tables();
        om_initialize_events();
        make_active();
        om_active = true;
    }

    /**
     * Have the entity exit the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle.
     */
    void exit_simulation()
    {
        om_finalize_entity_sets();
        om_finalize_tables();
        om_finalize_events();
        om_active = false;
        om_finalize_links();
        om_finalize_multilinks();
        make_inactive();
        make_zombie();
    }

    /**
     * Have all entities exit the simulation.
     * 
     * Can be called by framework model code as part of the simulation or case lifecycle.
     */
    static void exit_simulation_all()
    {
        // Iteration over agents needs to be robust to deletion of current iterator.
        assert(agents);
        auto it = agents->begin();
        while (it != agents->end()) {
            auto agent = *it;
            ++it; // increment iterator before erasing it from agents
            agent->exit_simulation();
        }
    }

    /**
     * Number of active agents.
     *
     * @return An int.
     */
    static int om_active_agents()
    {
        assert(agents);
        return agents->size();
    }

    /**
     * True if agent is active in the simulation.
     */
    bool om_active;

    /**
     * true if event trace is enabled
     *
     * This constant is defined by C++ code generated by omc.
     */
    static const bool event_trace_enabled;

    /**
     * true to turn on or off event trace from model code.
     * Accessed through API StartEventTrace and StopEventTrace.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool event_trace_on;

    /**
     * Values that represent the type of event trace message
     */
    enum et_msg_type {

        // event occurrence
        eEventOccurrence,

        // event scheduled time
        eEventScheduledTime
    };

    /**
     * Values that represent the report style of event trace messages
     */
    enum et_report_style {

        // like Modgen
        eModgen,

        // designed for reading
        eReadable
    };

    /**
     * The report style for event trace
     *
     * Defined by C++ code generated by omc.
     */
    static enum et_report_style event_trace_report_style;

    /**
     * Whether to show scheduling information in the event trace
     *
     * Defined by C++ code generated by omc.
     */
    static bool event_trace_show_scheduling;

    /**
     * Filter event trace by time (lower bound)
     *
     * Defined by C++ code generated by omc.
     */
    static double event_trace_minimum_time;

    /**
     * Filter event trace by time (upper bound)
     *
     * Defined by C++ code generated by omc.
     */
    static double event_trace_maximum_time;

    /**
     * Filter event trace by entities
     *
     * Defined by C++ code generated by omc.
     */
    static std::unordered_set<int> event_trace_selected_entities;

    /**
     * Filter event trace by events
     *
     * Defined by C++ code generated by omc.
     */
    static std::unordered_set<int> event_trace_selected_events;

    /**
     * Helper function to output a trace event message to the trace log.
     *
     * This function is used in code generated by omc.
     *
     * @param entity_name If non-null, name of the entity.
     * @param entity_id   Identifier for the entity.
     * @param case_seed   The case seed.
     * @param event_name  If non-null, name of the event.
     * @param time        The time.
     */
    static void event_trace_msg(
        const char* entity_name,
        int entity_id,
        double case_seed,
        int event_id,
        const char* event_description,
        double reported_time,
        double global_time,
        et_msg_type msg_type)
    {
        // Apply event trace filter conditions
        if (
               global_time < event_trace_minimum_time // before time window
            || global_time > event_trace_maximum_time // after time window
            || (event_trace_selected_entities.size() > 0 && event_trace_selected_entities.count(entity_id) == 0) // not in entity list
            || (event_trace_selected_events.size() > 0 && event_trace_selected_events.count(event_id) == 0)      // not in event list
            || (event_trace_show_scheduling == false && msg_type == eEventScheduledTime) // scheduling information disabled
            ) return;

        switch (event_trace_report_style) {
        case eModgen:
            {
                theTrace->logFormatted("%s - actor_id=%d - case_seed=%.0f -  : event=%s - time=%.15f",
                    entity_name,
                    entity_id,
                    case_seed,
                    event_description,
                    reported_time);
            }
            break;
        case eReadable:
            {
                // style is similar to that produced by test_models
                // using normalize_event_trace in common.pm
                switch (msg_type) {
                case eEventOccurrence:
                    {
                        assert(global_time == reported_time);
                        theTrace->logFormatted("%13.6f %s (%s %d)",
                            reported_time,
                            event_description,
                            entity_name,
                            entity_id);
                    }
                    break;
                case eEventScheduledTime:
                    {
                        //theTrace->logFormatted("                  %13.6f %s (%s %d)",
                        //    reported_time,
                        //    event_description,
                        //    entity_name,
                        //    entity_id);
                        theTrace->logFormatted("%13.6f     %13.6f %8d %s (%s)",
                            global_time,
                            reported_time,
                            entity_id,
                            event_description,
                            entity_name
                        );
                    }
                    break;
                default:
                    {
                        assert(false);
                    }
                } // switch (msg_type)
            }
            break;
        default:
            {
                assert(false);
            }
        } // switch (event_trace_report_style)
    }

    /**
     * Initializes run-time before simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of agent has
     * associated objects.
     */
    static void initialize_simulation_runtime();

    /**
     * Cleans up run-time after simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of agent has
     * associated objects.
     */
    static void finalize_simulation_runtime();

private:

    /**
     * The iterator of this agent in BaseEntity::agents.
     */
    std::list<BaseEntity *>::iterator iter_in_agents;

    /**
     * Active agents.
     */
    static thread_local std::list<BaseEntity *> *agents;
};

/**
 * Agent. Only instances of derived classes of Agent are actually created.
 *
 * @tparam A Type of a.
 */
template<typename A>
class Agent : public BaseEntity
{
public:

    /**
     * Agent allocation operator. This allocator recycles agents of the given type. Note that the
     * argument of new() is required for the correct signature but is not required or used.
     *
     * @param count Size of object (required for correct signature)
     *
     * @return The allocated object.
     */
    void *operator new( size_t count )
    {
		A *agent = nullptr;
        assert(available);
        if ( available->empty() ) {
			agent = ::new A;
        }
        else {
            agent = available->front();
            available->pop_front();
        }

        return agent;
    }

    void make_zombie()
    {
        assert(zombies);
        zombies->push_front( (A *)this );
    }

    /**
     * Free zombies. Move all zombie agents to the available list for re-use.
     */
    static void free_zombies()
    {
        assert(zombies);
        assert(available);
        while ( ! zombies->empty() ) {
            available->push_front( zombies->front() );
            zombies->pop_front();
        }
    }

    static thread_local std::forward_list<A *> *zombies;
    static thread_local std::forward_list<A *> *available;

};


/**
* Agent zombie list (definition)
*/

template<typename A>
thread_local std::forward_list<A *> *Agent<A>::zombies;

/**
* Agent available list (definition)
*/

template<typename A>
thread_local std::forward_list<A *> *Agent<A>::available;


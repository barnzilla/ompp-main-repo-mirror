/**
 * @file    Entity.h
 * Declares the Entity class and associated classes and templates
 *         
 */
// Copyright (c) 2013-2022 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

#pragma once
#include <list>
#include <forward_list>
#include <unordered_set>
#include <sstream>
#include <cassert>
#include "libopenm/omModel.h" // for theTrace
#include "globals0.h" // for handle_backwards_time
#include "om_types0.h" // for Time

/**
 * Base entity.
 */
class BaseEntity
{
public:

    /**
     * Access to run-time interface
     */
    static thread_local openm::IModel* i_model;

    /**
     * Explicitly declared virtual destructor
     * to allow safe delete of instances of derived classes.
     */
    virtual ~BaseEntity() = default;

    /**
     * Assign initial value to all data members in entity, with no side-effects. The function
     * definition is specific to each kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_data_members() = 0;

    /**
     * Get entity name
     */
    virtual const char * om_get_entity_name() = 0;

    /**
     * Assign unique entity_id to entity as part of initialization.
     */
    virtual void om_set_entity_id() = 0;

    /**
     * Get unique entity_id of entity.
     */
    virtual int om_get_entity_id() = 0;

    /**
     * Get current time of entity.
     */
    virtual Time om_get_time() = 0;

    /**
     * Get current age of entity.
     */
    virtual Time om_get_age() = 0;

    /**
     * Initialize time and age as part of entity initialization.
     */
    virtual void om_initialize_time_and_age() = 0;

    /**
     * Assign offset of each attribute and increment in the entity.
     * 
     * This function is called exactly once for each kind of entity to assign static members which
     * contain the offset of each attribute within the containing entity. This offset is used to
     * access the containing entity to invoke side-effects when the value of the attribute changes.
     * These offsets are fixed at compile time but the value cannot cannot be determined by the C++
     * compiler at the time of template instantiation.
     */
    virtual void om_assign_member_offsets() = 0;

    /**
     * Insert entity into entity sets of this entity type. The function definition is specific
     * to each kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_entity_sets() = 0;

    /**
     * Initialize value_in values for attributes used in tables. The function definition is specific
     * to each kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_tables() = 0;

    /**
     * Compute occurrence time for each event in entity. The function definition is specific to each
     * kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_initialize_events() = 0;

    /**
     * Remove entity from entity sets of this entity type. The function definition is specific to each kind of entity
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_entity_sets() = 0;

    /**
     * Complete all pending table updates. The function definition is specific to each kind of entity
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_tables() = 0;

    /**
     * Initialize identity attributes by evaluating their associated expressions.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_identity_attributes() = 0;

    /**
     * Initialize derived attributes by evaluating injected code.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_initialize_derived_attributes() = 0;

    /**
     * Initialize local RNG streams, if present.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void initialize_local_random_streams(void) = 0;

    /**
     * Check that starting value of time is valid and raise run-time error if not.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_check_starting_time() = 0;

    /**
     * Reset derived attributes by evaluating injected code.
     * The function definition is specific to each kind of entity and is generated by the openM++
     * compiler.
     */
    virtual void om_reset_derived_attributes() = 0;

    /**
     * Finalize entity events (remove from event queue). The function definition is specific to each
     * kind of entity and is generated by the openM++ compiler.
     */
    virtual void om_finalize_events() = 0;

    /**
     * Sets all links in the entity to nullptr when the entity leaves the simulation.
     */
    virtual void om_finalize_links() = 0;

    /**
     * Empties all multilinks in the entity when the entity leaves the simulation.
     */
    virtual void om_finalize_multilinks() = 0;

    /**
     * Does trace messages at start of entity lifecycle.
     */
    virtual void om_start_trace() = 0;

    /**
     * Age the entity to the given time.
     *
     * @param t The target time.
     */
    virtual void age_entity( Time t ) = 0;

    /**
     * Add the entity to the zombie list for entities of this type.
     */
    virtual void make_zombie() = 0;

    /**
     * Handle microdata output.
     */
    virtual void write_microdata() = 0;

    /**
     * Handle lifecycle attribute maintenance on enter_simulation.
     */
    virtual void om_lifecycle_enter() = 0;

    /**
     * Handle lifecycle attribute maintenance on exit_simulation.
     */
    virtual void om_lifecycle_exit() = 0;

    /**
     * Age all entities to the given time.
     * 
     * If originating_entity_id is not supplied, no check for time running backwards is performed
     * 
     * @param t                     The target time.
     * @param originating_entity_id Identifier of the entity within which the event occurred.
     */
    static void age_all_entities( Time t, int originating_entity_id = -1, int originating_event_id = -1)
    {
        assert(entities);
        for ( auto entity : *entities ) {
            if (entity->om_get_entity_id() == originating_entity_id) {
                // This is the entity within which the event occurred.
                // Check for time running backwards in the entity within which the event occurred
                if (t < entity->om_get_time()) {
                    // The time of this event is in the local past of the entity within which the event occurs.
                    // This is an error in model logic.
                    // Write log message and throw run-time exception.
                    handle_backwards_time(
                        entity->om_get_time(),
                        t,
                        originating_event_id,
                        originating_entity_id
                    );
                }
            }
            entity->age_entity( t );
        }
        // Note that global time is updated in framework module
        // by calling BaseEvent::set_global_time(t);
    }

    /**
     * Move all entities from zombie lists to corresponding available list.
     * 
     * The function definition is generated by the openM++ compiler.
     */
    static void free_all_zombies();

    /**
     * Adds the entity to the list of active entities.
     */
    void make_active()
    {
        assert(entities);
        entities->push_front( this );
        iter_in_entities = entities->begin();
    }

    /**
     * Removes the entity from the list of active entities.
     */    
    void make_inactive()
    {
        assert(entities);
        entities->erase(iter_in_entities);
    }

    /**
     * Initialize all attributes of the entity.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the beginning of a member function named Start().
     */
    void initialize_attributes()
    {
        om_active = false;
        om_initialize_data_members();
        om_set_entity_id();
        om_initialize_time_and_age();
        om_initialize_derived_attributes();
        om_initialize_identity_attributes();
    }

    /**
     * Have the entity enter the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle,
     * generally at the end of a member function named Start().
     */
    void enter_simulation()
    {
        om_check_starting_time();
        om_reset_derived_attributes();
        om_initialize_identity_attributes();
        om_initialize_entity_sets();
        om_initialize_tables();
        om_initialize_events();
        initialize_local_random_streams();
        make_active();
        om_active = true;
        om_lifecycle_enter();
        if constexpr (om_microdata_output_capable && om_microdata_write_on_enter) {
            write_microdata();
        }
        if constexpr (om_event_trace_capable) {
            extern double GetCaseSeed();
            if (event_trace_on) {
                event_trace_msg(
                    om_get_entity_name(),
                    (int)om_get_entity_id(),
                    (double)om_get_age(),
                    GetCaseSeed(),
                    "", // no associated event
                    -1, // no associated event
                    "enter_simulation",
                    om_get_time(), // the value of time in the entity before it enters the simulation
                    om_get_age(), // the value of age in the entity before it enters the simulation
                    om_get_time(), // the noted time for event trace
                    et_msg_type::eEnterSimulation
                );
                om_start_trace();  // event_trace_msg calls for initial values of attributes
            }
        }
    }

    /**
     * Have the entity exit the simulation.
     * 
     * Called by model developer code as part of the entity lifecycle.
     */
    void exit_simulation()
    {
        om_lifecycle_exit();
        if constexpr (om_microdata_output_capable && om_microdata_write_on_exit) {
            write_microdata();
        }
        if constexpr(om_event_trace_capable) {
            extern double GetCaseSeed();
            if (event_trace_on) {
                event_trace_msg(
                    om_get_entity_name(),
                    (int)om_get_entity_id(),
                    (double)om_get_age(),
                    GetCaseSeed(),
                    "", // no associated event
                    -1, // no associated event
                    "exit_simulation",
                    om_get_time(), // the value of time in the entity when it exits the simulation
                    om_get_age(), // the value of age in the entity when it exits the simulation
                    get_global_time(),
                    et_msg_type::eExitSimulation
                );
            }
        }
        om_finalize_entity_sets();
        om_finalize_tables();
        om_finalize_events();
        om_active = false;
        om_finalize_links();
        om_finalize_multilinks();
        make_inactive();
        make_zombie();
    }

    /**
     * Have all entities exit the simulation.
     * 
     * Can be called by framework model code as part of the simulation or case lifecycle.
     */
    static void exit_simulation_all()
    {
        // Iteration over entities needs to be robust to deletion of current iterator.
        assert(entities);
        auto it = entities->begin();
        while (it != entities->end()) {
            auto entity = *it;
            ++it; // increment iterator before erasing it from entities
            entity->exit_simulation();
        }
    }

    /**
     * Number of active entities.
     *
     * @return An int.
     */
    static size_t om_active_entities()
    {
        assert(entities);
        return entities->size();
    }

    /**
     * True if entity is active in the simulation.
     */
    bool om_active;

    /**
     * Allow or disallow access to null entity through null pointer
     *
     * If not allowed, will raise runtime exception.
     * If allowed (when evaluating identity attribute expressions),
     * allows read access to the special 'null entity' containing
     * default values.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool om_access_to_null_entity;

    /**
     * Allow or disallow modification of attributes
     *
     * Only in effect if constexpr om_verify_attribute_modification is true.
     * If in effect, will raise runtime exception on attempt to modify
     * an attribute in an event time function.
     * Turned on or off to permit or deny attribute modification 
     * in event lifecycle code.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool om_permit_attribute_modification;

    /**
     * Allow or disallow access to time-like attributes
     *
     * Only in effect if constexpr om_verify_ timelike_attribute_access is true.
     * If in effect, will raise runtime exception on attempt to access
     * a time-like attribute in an event time function.
     * Turned on or off to permit or deny access to time-like attribute
     * in event lifecycle code.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool om_permit_timelike_attribute_access;

    /**
     * Turn on or off event trace from model code.
     * Accessed through API StartEventTrace and StopEventTrace.
     * Has no effect if constexpr om_event_trace_capable is false.
     *
     * Defined by C++ code generated by omc.
     */
    static thread_local bool event_trace_on;

    /**
     * Values that represent the type of event trace message
     */
    enum class et_msg_type {

        // event occurrence
        eEventOccurrence,

        // self-scheduling event occurrence
        eSelfSchedulingEventOccurrence,

        // queued event
        eQueuedEvent,

        // queued self-scheduling event
        eQueuedSelfSchedulingEvent,

        // enter simulation
        eEnterSimulation,

        // enter simulation
        eExitSimulation,

        // starting attribute value
        eAttributeStart,

        // change of attribute value
        eAttributeChange,

        // starting link attribute value
        eLinkAttributeStart,

        // change of link attribute value
        eLinkAttributeChange,

        // starting multilink value
        eMultilinkStart,

        // change in multilink - insert entity 
        eMultilinkInsert,

        // change in multilink - erase entity 
        eMultilinkErase,

        // entity added to selected entities because linked
        eSnowball,

        // entity table increment
        eTableIncrement,
    };

    /**
     * Values that represent the report style of event trace messages
     */
    enum class et_report_style {

        // like Modgen
        eModgen,

        // designed for reading
        eReadable,

        // designed for post-processing
        eCsv
    };

    /**
     * The report style for event trace
     */
    inline static enum et_report_style event_trace_report_style = BaseEntity::et_report_style::eModgen;

    /**
     * Whether to show normal events in the event trace
     */
    inline static bool event_trace_show_events = true;

    /**
     * Whether to show queued normal events in the event trace
     */
    inline static bool event_trace_show_queued_events = true;

    /**
     * Whether to show queued self-scheduling events in the event trace
     */
    inline static bool event_trace_show_queued_self_scheduling_events = true;

    /**
     * Whether to show queued events with unchanged time-to-event in the event trace
     */
    inline static bool event_trace_show_queued_unchanged = false;

    /**
     * Whether to show enter simulation information in the event trace
     */
    inline static bool event_trace_show_enter_simulation = true;

    /**
     * Whether to show exit simulation information in the event trace
     */
    inline static bool event_trace_show_exit_simulation = true;

    /**
     * Whether to show self-scheduling events in the event trace
     */
    inline static bool event_trace_show_self_scheduling_events = true;

    /**
     * Whether to show changes in attributes
     */
    inline static bool event_trace_show_attributes = false;

    /**
     * Whether to show table increments in the event trace
     */
    inline static bool event_trace_show_table_increments = false;

    /**
     * Filter event trace by time (lower bound)
     */
    inline static double event_trace_minimum_time = -std::numeric_limits<double>::infinity();

    /**
     * Filter event trace by time (upper bound)
     */
    inline static double event_trace_maximum_time = std::numeric_limits<double>::infinity();

    /**
     * Filter event trace by age (lower bound)
     */
    inline static double event_trace_minimum_age = -std::numeric_limits<double>::infinity();

    /**
     * Filter event trace by age (upper bound)
     */
    inline static double event_trace_maximum_age = std::numeric_limits<double>::infinity();

    /**
     * Filter event trace by case seeds
     */
    inline static std::unordered_set<double> event_trace_selected_case_seeds;

    /**
     * Filter event trace by entity kinds
     */
    inline static std::unordered_set<std::string> event_trace_selected_entity_kinds;

    /**
     * Filter event trace by entities
     */
    inline static std::unordered_set<int> event_trace_selected_entities;

    /**
     * Whether to show linked entities
     */
    inline static bool event_trace_select_linked_entities = false;

    /**
     * Filter event trace by events
     */
    inline static std::unordered_set<int> event_trace_selected_events;

    /**
     * Filter event trace by attributes
     */
    inline static std::unordered_set<int> event_trace_selected_attributes;

    /**
     * Filter event trace by attribute value (lower bound)
     */
    inline static double event_trace_minimum_attribute = -std::numeric_limits<double>::infinity();

    /**
     * Filter event trace by attribute value (upper bound)
     */
    inline static double event_trace_maximum_attribute = std::numeric_limits<double>::infinity();

    /**
     * Filter event trace by tables
     */
    inline static std::unordered_set<int> event_trace_selected_tables;

    /**
     * Used to set report column width for names
     */
    inline static int event_trace_name_column_width = 40;

    /**
     * Used to control maximum number of output lines in event trace
     */
    inline static int event_trace_maximum_lines = 20000;

    /**
     * Counter for event trace line
     */
    inline static int event_trace_line_counter = 0;

    /**
     * @fn  static void BaseEntity::event_trace_msg( const char* entity_name, int entity_id, double entity_age, double case_seed, const char* cstr1, int other_id, const char* cstr2, double dbl1, double dbl2, double global_time, et_msg_type msg_type)
     *
     * @brief   Format an event trace message and output it to the trace.
     *          
     *          This function is used in code generated by omc.
     *
     * @param   entity_name If non-null, name of the entity.
     * @param   entity_id   Identifier for the entity.
     * @param   entity_age  The entity age.
     * @param   case_seed   The case seed.
     * @param   cstr1       The cstr #1.
     * @param   other_id    An integer (maybe an id).
     * @param   cstr2       The cstr #2.
     * @param   dbl1        The double #1.
     * @param   dbl2        The double #2.
     * @param   global_time The global time.
     * @param   msg_type    Type of the message.
     */
    static void event_trace_msg(
        const char* entity_name,
        int entity_id,
        double entity_age,
        double case_seed,
        const char* cstr1,
        int other_id,
        const char* cstr2,
        double dbl1,
        double dbl2,
        double noted_time,
        et_msg_type msg_type)
    {
        // Apply maximum line limit independent of report style
        if (event_trace_maximum_lines <= 0) {
            // Maximum line count exceeded
            if (event_trace_maximum_lines == 0) {
                theTrace->logFormatted(LT("Maximum lines exceeded, increase using EventTrace.MaximumLines"));
                event_trace_maximum_lines = -1;
            }
            return;
        }

        //
        // modgen report style
        // 

        if (event_trace_report_style == et_report_style::eModgen) {
            switch (msg_type) {
            case et_msg_type::eEventOccurrence:
            case et_msg_type::eQueuedEvent:
            case et_msg_type::eSelfSchedulingEventOccurrence:
            {
                // decrement the count af remaining lines before maximum reached
                event_trace_maximum_lines--;

                auto& the_time = dbl1;
                auto& the_name = cstr2;
                theTrace->logFormatted("%s - actor_id=%d - case_seed=%.0f -  : event=%s - time=%.15f",
                    entity_name,
                    entity_id,
                    case_seed,
                    the_name,
                    the_time);
            }
            break;
            // ignore all other message types for modgen style output
            default:
                break;
            }
            return;
        }

        //
        // readable or csv report style
        // 
        bool isReadable = event_trace_report_style == et_report_style::eReadable;
        bool isCsv = event_trace_report_style == et_report_style::eCsv;
        assert(isReadable || isCsv );

        // Apply event trace filter conditions
        if (event_trace_selected_entity_kinds.size() > 0 && event_trace_selected_entity_kinds.count(entity_name) == 0) {
            // Block message not in entity kind list (if non-empty).
            return;
        }
        if (msg_type == et_msg_type::eEnterSimulation && !event_trace_show_enter_simulation) {
            // Enter simulation messages are blocked.
            return;
        }
        if (msg_type == et_msg_type::eExitSimulation && !event_trace_show_exit_simulation) {
            // Entity exit simulation messages are blocked.
            return;
        }
        if (msg_type == et_msg_type::eEventOccurrence && !event_trace_show_events) {
            // Event occurrence messages are blocked.
            return;
        }
        if (msg_type == et_msg_type::eSelfSchedulingEventOccurrence && !event_trace_show_self_scheduling_events) {
            // Self-scheduling event messages are blocked.
            return;
        }
        if (msg_type == et_msg_type::eQueuedEvent && !event_trace_show_queued_events) {
            // Queued event messages are blocked.
            return;
        }
        if (msg_type == et_msg_type::eQueuedSelfSchedulingEvent && !event_trace_show_queued_self_scheduling_events) {
            // Queued self-scheduling event messages are blocked.
            return;
        }
        if ((
               msg_type == et_msg_type::eEventOccurrence
            || msg_type == et_msg_type::eQueuedEvent
            ) && (event_trace_selected_events.size() > 0 && event_trace_selected_events.count(other_id) == 0)) {
            // Block event message not in event list (if non-empty).
            return;
        }
        if (msg_type == et_msg_type::eTableIncrement && !event_trace_show_table_increments) {
            // Table increment messages are blocked.
            return;
        }
        if ((
            msg_type == et_msg_type::eTableIncrement
            ) && (event_trace_selected_tables.size() > 0 && event_trace_selected_tables.count(other_id) == 0)) {
            // Block table increment message not in table list (if non-empty).
            return;
        }
        if ((
               msg_type == et_msg_type::eAttributeStart
            || msg_type == et_msg_type::eAttributeChange
            || msg_type == et_msg_type::eLinkAttributeStart
            || msg_type == et_msg_type::eLinkAttributeChange
            || msg_type == et_msg_type::eMultilinkStart
            || msg_type == et_msg_type::eMultilinkInsert
            || msg_type == et_msg_type::eMultilinkErase
            ) && (
                    !event_trace_show_attributes
                    || (event_trace_selected_attributes.size() > 0 && event_trace_selected_attributes.count(other_id) == 0)
                    )
            ) {
            // Attribute messages blocked, or attribute not in list (if non-empty)
            return;
        }
        if ((msg_type == et_msg_type::eAttributeStart && event_trace_show_attributes)
            && (
                   dbl1 < event_trace_minimum_attribute
                || dbl1 > event_trace_maximum_attribute
                )
            ) {
            // Block attribute initial message with value outside allowed limite
            return;
        }
        if ((msg_type == et_msg_type::eAttributeChange && event_trace_show_attributes)
            && (
                   dbl2 < event_trace_minimum_attribute
                || dbl2 > event_trace_maximum_attribute
                )
            ) {
            // Block attribute change message with value outside allowed limits
            return;
        }
        if (noted_time < event_trace_minimum_time) {
            // Block message before the allowed time window.
            return;
        }
        if (noted_time > event_trace_maximum_time) {
            // Block message after the allowed time window.
            return;
        }
        if (entity_age < event_trace_minimum_age) {
            // Block message before the allowed age window.
            return;
        }
        if (entity_age > event_trace_maximum_age) {
            // Block message after the allowed age window.
            return;
        }
        if (event_trace_selected_entities.size() > 0 && event_trace_selected_entities.count(entity_id) == 0) {
            // Block message from entity not in list (if non-empty).
            return;
        }
        if (event_trace_selected_case_seeds.size() > 0 && event_trace_selected_case_seeds.count(case_seed) == 0) {
            // Block message if case seed not in list (if non-empty).
            return;
        }

        // target width of name column in report
        const int name_colwidth = BaseEntity::event_trace_name_column_width;

        // width of 'what' column
        const int what_width = 11;

        // column headers
        static bool header_done = false;
        if (!header_done) {
            header_done = true;
            if (isReadable) {
                theTrace->logFormatted(
                    "%13s %8.8s %10s %8s %-*s %13s %-*s %s",
                    "Time",
                    "Entity",
                    "Age",
                    "Id",
                    what_width,
                    "Trace",
                    "Value",
                    name_colwidth,
                    "Name",
                    "    Remarks"
                );
            }
            else if (isCsv) {
                theTrace->logFormatted(
                    "Line,Time,Entity,Age,Id,Trace,Value,Name,Remarks"
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
            event_trace_maximum_lines--;
        }

        // decrement the count of remaining lines before maximum reached
        event_trace_maximum_lines--;

        // increment the line counter
        event_trace_line_counter++;

        // Readable style is similar to that produced by test_models
        // using normalize_event_trace in Perl common.pm
                
        switch (msg_type) {
        case et_msg_type::eEventOccurrence:
        {
            auto what = "  EVENT";
            auto what_trimmed = "EVENT";
            auto& event_name = cstr1;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    "", // no value
                    name_colwidth,
                    event_name
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",,\"%s\",",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    // no value
                    event_name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eSelfSchedulingEventOccurrence:
        {
            auto what = "  EVENT";
            auto what_trimmed = "EVENT";
            auto& event_name = cstr1;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    "", // no value
                    name_colwidth,
                    event_name // is pretty name, eg trigger_changes(calendar_year)
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",,\"%s\",",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    // no value
                    event_name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eQueuedEvent:
        {
            auto what = "    queued";
            auto what_trimmed = "queued";
            auto& new_time = dbl1;
            auto& old_time = dbl2;
            auto& event_name = cstr1;
            //auto& timefn_name = cstr2; // name of event time function, eg timeMigrationEvent
            if (!event_trace_show_queued_unchanged && (new_time == old_time)) {
                // Do not report if time-to-event did not change.
                break;
            }
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.6f     %-*s was %.6f",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    new_time,
                    name_colwidth,
                    event_name,
                    old_time
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%.13g,\"%s\",\"was %.6f\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    new_time,
                    event_name,
                    old_time
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eQueuedSelfSchedulingEvent:
        {
            auto what = "    queued";
            auto what_trimmed = "queued";
            auto& new_time = dbl1;
            auto& event_name = cstr1;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.6f     %-*s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    new_time,
                    name_colwidth,
                    event_name // is pretty name, eg trigger_changes(calendar_year)
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%.13g,\"%s\",",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    new_time,
                    event_name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eEnterSimulation:
        {
            auto what = "ENTER";
            auto what_trimmed = "ENTER";
            //auto& entity_time = dbl1;
            //auto& description  = cstr2; // is "enter_simulation"
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    "", // no value
                    name_colwidth,
                    "" // no name
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",,,",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed
                    // no value
                    // no name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eExitSimulation:
        {
            auto what = "EXIT";
            auto what_trimmed = "EXIT";
            //auto& entity_time = dbl1;
            //auto& description = cstr2; // is "exit_simulation"
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s %-*s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    "", // no Value
                    name_colwidth,
                    "" // no Name
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",,,",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed
                    // no value
                    // no name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eAttributeStart:
        {
            auto what = "    attr";
            auto what_trimmed = "attr";
            auto& start_value = dbl1;
            auto& attribute_name = cstr2;   // name of attribute eg 'year'
            std::stringstream ss;
            ss << std::setw(9) << std::setprecision(4) << start_value;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.13g   %-*s   initial",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    start_value,
                    name_colwidth,
                    attribute_name
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%.13g,\"%s\",\"initial\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    start_value,
                    attribute_name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eAttributeChange:
        {
            auto what = "    attr";
            auto what_trimmed = "attr";
            auto& old_value = dbl1;
            auto& new_value = dbl2;
            auto& attribute_name = cstr2;   // name of attribute eg 'year'
            std::stringstream ss;
            ss << std::setw(9) << std::setprecision(4) << new_value;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.13g   %-*s   was %.13g",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    //ss.str().c_str(),
                    new_value,
                    name_colwidth,
                    attribute_name,  // is name of attribute eg year
                    old_value
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%.13g,\"%s\",\"was %.13g\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    new_value,
                    attribute_name,
                    old_value
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eLinkAttributeStart:
        {
            auto what = "    link";
            auto what_trimmed = "link";
            auto& start_value = dbl1;
            auto& attribute_name = cstr2;   // name of link attribute eg 'lSpouse'
            std::stringstream ss;
            if (start_value >= 0) {
                // starting link value is the entity_id of the entity
                ss << (int)start_value;
            }
            else {
                // starting link value is nullptr
                ss << "nullptr";
            }
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s   %-*s   initial",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    ss.str().c_str(),
                    name_colwidth,
                    attribute_name
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%s,\"%s\",\"initial\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    ss.str().c_str(),
                    attribute_name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eLinkAttributeChange:
        {
            auto what = "    link";
            auto what_trimmed = "link";
            auto& old_value = dbl1;
            auto& new_value = dbl2;
            auto& attribute_name = cstr2;   // name of link attribute eg 'lSpouse'
            std::stringstream ss_new;
            if (new_value >= 0) {
                // new link value is the entity_id of the entity
                ss_new << (int)new_value;
            }
            else {
                // new link value is nullptr
                ss_new << "nullptr";
            }
            std::stringstream ss_old;
            if (old_value >= 0) {
                // old link value is the entity_id of the entity
                ss_old << (int)old_value;
            }
            else {
                // old link value is nullptr
                ss_old << "nullptr";
            }
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s   %-*s   was %s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    ss_new.str().c_str(),
                    name_colwidth,
                    attribute_name,
                    ss_old.str().c_str()
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%s,\"%s\",\"was %s\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    ss_new.str().c_str(),
                    attribute_name,
                    ss_old.str().c_str()
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eMultilinkStart:
        {
            auto what = "    multi";
            auto what_trimmed = "multi";
            auto& multilink_name = cstr2;   // name of the multilink, eg 'mlChildren'
            auto& contents = cstr1; // comma-separated list of entity_id's
            std::stringstream ss;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13s   %-*s   initial {%s}",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    "", // no value
                    name_colwidth,
                    multilink_name,
                    contents
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",,\"%s\",\"initial {%s}\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    // no value
                    multilink_name,
                    contents
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eMultilinkInsert:
        {
            auto what = "    multi++";
            auto what_trimmed = "multi++";
            int ent_id = (int)dbl1;
            auto& contents = cstr1; // comma-separated list of entity_id's
            auto& multilink_name = cstr2;   // name of the multilink, eg 'mlChildren'
            std::stringstream ss;
            ss << ent_id;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13d   %-*s   is {%s}",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    //ss.str().c_str(),
                    ent_id,
                    name_colwidth,
                    multilink_name,
                    contents
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%d,\"%s\",\"is {%s}\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    ent_id,
                    multilink_name,
                    contents
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eMultilinkErase:
        {
            auto what = "    multi--";
            auto what_trimmed = "multi--";
            int ent_id = (int)dbl1;
            auto& contents = cstr1; // comma-separated list of entity_id's
            auto& multilink_name = cstr2;   // name of the multilink, eg 'mlChildren'
            std::stringstream ss;
            ss << ent_id;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13d   %-*s   is {%s}",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    //ss.str().c_str(),
                    ent_id,
                    name_colwidth,
                    multilink_name,
                    contents
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%d,\"%s\",\"is {%s}\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    ent_id,
                    multilink_name,
                    contents
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eSnowball:
        {
            auto what = " selected++";
            auto what_trimmed = "selected++";
            auto& name = cstr2;   // name of the link or multilink, eg 'mlChildren'
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13d   %-*s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    other_id,
                    name_colwidth,
                    name
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%d,\"%s\",",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    other_id,
                    name
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        case et_msg_type::eTableIncrement:
        {
            auto what = "  INCREMENT";
            auto what_trimmed = "INCREMENT";
            //auto& table_id = other_id; // not used in message
            auto& increment = dbl1;
            auto& accumulator = dbl2;
            auto& table_name = cstr2;
            auto& cell_formatted = cstr1;
            std::stringstream remarks;
            remarks << "cell=" << cell_formatted << " accumulator=" << std::setprecision(6) << accumulator;
            if (isReadable) {
                theTrace->logFormatted("%13.6f %8.8s %10.6f %8d %-*s %13.6g   %-*s   %s",
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_width,
                    what,
                    increment,
                    name_colwidth,
                    table_name,
                    remarks.str().c_str()
                );
            }
            else if (isCsv) {
                theTrace->logFormatted("%d,%.13g,\"%s\",%.13g,%d,\"%s\",%.13g,\"%s\",\"%s\"",
                    event_trace_line_counter,
                    noted_time,
                    entity_name,
                    entity_age,
                    entity_id,
                    what_trimmed,
                    increment,
                    table_name,
                    remarks.str().c_str()
                );
            }
            else {
                // NOT_REACHED
                assert(false);
            }
        }
        break;
        default:
            {
                assert(false);
            }
        } // switch (msg_type)
    }

    /**
     * Initializes run-time before simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of entity has
     * associated objects.
     */
    static void initialize_simulation_runtime();

    /**
     * Cleans up run-time after simulation.
     * 
     * The function definition is generated by the openM++ compiler, because each type of entity has
     * associated objects.
     */
    static void finalize_simulation_runtime();

private:

    /**
     * The iterator of this entity in BaseEntity::entities.
     */
    std::list<BaseEntity *>::iterator iter_in_entities;

    /**
     * Active entities (polymorphic)
     */
    static thread_local std::list<BaseEntity *> *entities;
};

/**
 * Entity. Only instances of derived classes of Entity are actually created.
 *
 * @tparam A Type of a.
 */
template<typename E>
class Entity : public BaseEntity
{
public:

    /**
     * Entity allocation operator. This allocator recycles entities of the given type. Note that the
     * argument of new() is required for the correct signature but is not used.
     *
     * @param count Size of object (required for correct signature)
     *
     * @return The allocated object.
     */
    void *operator new( size_t count )
    {
		E *entity = nullptr;
        if constexpr (om_resource_use_on) {
            ++activation_count;
        }
        assert(available);
        if ( available->empty() ) {
			entity = ::new E;
            if constexpr (om_resource_use_on) {
                ++allocation_count;
            }
        }
        else {
            entity = available->front();
            available->pop_front();
        }

        return entity;
    }

    void make_zombie()
    {
        assert(zombies);
        zombies->push_front( (E *)this );
    }

    /**
     * Free zombies. Move all zombie entities to the available list for re-use.
     */
    static void free_zombies()
    {
        assert(zombies);
        assert(available);
        while ( ! zombies->empty() ) {
            available->push_front( zombies->front() );
            zombies->pop_front();
        }
    }

    /**
     * Free available list and release associated memory.
     */
    static void free_available()
    {
        assert(available);
        while (!available->empty()) {
            delete *available->front();
            available->pop_front();
        }
    }

    /**
     * Resource use information for the entity
     */
    static auto resource_use()
    {
        struct result { size_t allocations; size_t activations; };
        return result { allocation_count, activation_count };
    }

    /**
     * Reset resource use information for the entity
     */
    static void resource_use_reset()
    {
        allocation_count = 0;
        activation_count = 0;
    }

    static thread_local std::forward_list<E *> *zombies;
    static thread_local std::forward_list<E *> *available;

    /**
    * Count of allocations
    *
    * The number of allocations from c++ memory allocator.
    * Note that because of re-use, this is not necessarily the same as the number of
    * invocations of 'new' in model code.
    */
    static thread_local std::size_t allocation_count;

    /**
    * Count of activations
    * 
    * The number invocations of 'new' in model code.
    * This is not necessarily the same as the number of allocations from c++ memory allocator.
    */
    static thread_local std::size_t activation_count;
};


/**
* Entity zombie list (definition)
*/

template<typename E>
thread_local std::forward_list<E *> *Entity<E>::zombies;

/**
* Entity available list (definition)
*/

template<typename E>
thread_local std::forward_list<E *> *Entity<E>::available;

template<typename E>
thread_local std::size_t Entity<E>::allocation_count = 0;

template<typename E>
thread_local std::size_t Entity<E>::activation_count = 0;

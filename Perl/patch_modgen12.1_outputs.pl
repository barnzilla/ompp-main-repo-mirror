# Copyright (c) 2013-2023 OpenM++ Contributors
# This code is licensed under the MIT license (see LICENSE.txt for details)

# Script to modify Modgen output files for cross-compatible models

use strict;
use File::Temp qw(tempfile);
use File::Copy;


my $version = 1.1;

if ( $#ARGV != 0 ) {
	# must have 1 argument
	print "patch_modgen12_outputs version $version\n";
	print "usage: patch_modgen12_outputs dir\n";
	print "  example: patch_modgen12_outputs Alpha1/modgen/src\n";
	exit 1;
}

# Control verbosity of log output (0, 1, 2)
my $verbosity = 0;

my $script_name = "patch_modgen_outputs";

# Directory containing Modgen output files
my $src_dir = shift @ARGV;

use common qw(
				warning change error info
		    );
# Check for compile errors, and bail if any.
if ($@) {
	print $@;
	exit 1;
}

if (!-d $src_dir) {
	logmsg error, $script_name, "Directory ${src_dir} does not exist\n";
	exit 1;
}

#
# ACTORS.H
#
# Also, build list of entity names in the model
#
my @entities;

{
	my $file_name = 'ACTORS.H';
	my $actors_h = "${src_dir}/${file_name}";
	if (!-f $actors_h) {
		logmsg error, $script_name, "File ${actors_h} not found\n";
		exit 1;
	}
	(my $fh, my $filename) = tempfile();
	open ACTORS_H, "<".$actors_h;
	
	my $in_classifications = 0;
	my $classification_name = '';
	my $in_ranges = 0;
	my $in_partitions = 0;
	my $in_entity = 0;
	my $entity_name = '';
	while (<ACTORS_H>) {
		chomp;
		my $line = $_;

		# detect entity class declaration
		if ($line =~ /^class (\w+) : public ActorClass {/ ) {
			$in_entity = 1;
			$entity_name = $1;
			# build list of entity names
			push @entities, $entity_name;
		}
		if ($line eq "};") {
			$in_entity = 0;
		}

		# detect classification, range, partition block
		if ($line eq "// classifications") {
			$in_classifications = 1;
		}
		if ($line eq "// ranges") {
			$in_classifications = 0;
			$in_ranges = 1;
		}
		if ($line eq "// partitions") {
			$in_partitions = 1;
			$in_ranges = 0;
		}
		if ($line eq "class Parameters {") {
			$in_partitions = 0;
		}
		
		if ($in_entity) {
			if ($line =~ /special functions generated by the pre-compiler/) {
				# construct do-nothing write_microdata member function
				my $line2 = "\t\tvoid write_microdata(void) { };  // Inserted by patch_modgenXX_outputs after Modgen compilation.";

				# Append line2 to original line
				$line = $line."\n".$line2;
				print "patched ${file_name}: $line2\n";
			}
		}
		
		# Print the line (perhaps modified)
		print $fh $line."\n";
	}
	close $fh;
	close ACTORS_H;
	copy $filename, $actors_h;
	unlink $filename;
}

#
# MODEL.H
#

{
	my $file_name = 'MODEL.H';
	my $model_h = "${src_dir}/${file_name}";
	if (!-f $model_h) {
		logmsg error, $script_name, "File ${model_h} not found\n";
		exit 1;
	}
	(my $fh, my $filename) = tempfile();
	open MODEL_H, "<".$model_h;
	while (<MODEL_H>) {
		chomp;
		my $line = $_;
		print $fh $line."\n";
	}
	
	# append definitions of mind, etc.
	my $code = <<'END_CODE';
	
//
// The following code was inserted by patch_modgenXX_outputs after Modgen compilation:
//

#if !defined(NO_LT)
// NO_LT macro is used in OpenM++ to suppress translation, for example: WarningMsg( NO_LT("};") );
#define NO_LT(sourceMessage) sourceMessage
#endif  // !defined(MODGEN)

namespace mm {
    // Cross-compatible functions to save/restore random state to support cloning.
    // Definitions in modgen_random_state.mpp
    extern void store_random_state();
    extern void retrieve_random_state();
};

// The following seems required in some versions of VS 2019 when requesting C++17
#include <set>

// minimum of two doubles
inline double mind(double a, double b)
{
    return (b < a ? b : a);
}

// maximum of two doubles
inline double maxd(double a, double b)
{
    return (a < b ? b : a);
}

// clamped value of a double
inline double clampd(double v, double lo, double hi)
{
    return (v < lo ? lo : v > hi ? hi : v);
}

// minimum of two ints
inline int mini(int a, int b)
{
    return (b < a ? b : a);
}

// maximum of two ints
inline int maxi(int a, int b)
{
    return (a < b ? b : a);
}

// clamped value of an int
inline int clampi(int v, int lo, int hi)
{
    return (v < lo ? lo : v > hi ? hi : v);
}
END_CODE

	print $fh $code;
	
	close $fh;
	close MODEL_H;
	copy $filename, $model_h;
	unlink $filename;
}

exit 0;

/**
 * @file    Agent.h
 * Declares the Agent class and associated classes and templates
 *         
 */
// Copyright (c) 2013-2014 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

#pragma once
#include <list>
#include <forward_list>
#include "om_types0.h" // for Time

using namespace std;

/**
    * Base agent.
    */

class BaseAgent
{
public:

    /**
     * Assign initial value to all data members in agent, with no side-effects. The function
     * definition is specific to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_data_members() = 0;

    /**
     * Assign unique agent_id to agent as part of initialization.
     */
    virtual void om_set_agent_id() = 0;

    /**
     * One-time initialization of the offset of each agentvar in each type of agent. This offset is
     * used to invoke side-effects when agentvar values change.
     */
    virtual void om_initialize_agentvar_offsets() = 0;

    /**
     * One-time initialization of the offset of each event in each type of agent.
     */
    virtual void om_initialize_event_offsets() = 0;

    /**
     * Initialize value_in values for agentvars used in tables. The function definition is specific
     * to each kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_tables() = 0;

    /**
     * Compute occurrence time for each event in agent. The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_events() = 0;

    /**
     * Complete all pending table updates. The function definition is specific to each kind of agent
     * and is generated by the openM++ compiler.
     */
    virtual void om_finalize_tables() = 0;

    /**
     * Initialize all expression agentvars. The function definition is specific to each kind of
     * agent and is generated by the openM++ compiler.
     */
    virtual void om_initialize_expression_agentvars() = 0;

    /**
     * Finalize agent events (remove from event queue). The function definition is specific to each
     * kind of agent and is generated by the openM++ compiler.
     */
    virtual void om_finalize_events() = 0;

    /**
     * Sets all links in the agent to nullptr when the agent leavesthe simulation.
     */
    virtual void om_finalize_links() = 0;

    /**
     * Age the agent to the given time.
     *
     * @param t The target time.
     */
    virtual void age_agent( Time t ) = 0;

    /**
     * Add the agent to the zombie list for agents of this type.
     */
    virtual void make_zombie() = 0;

    /**
     * Age all agents to the given time.
     *
     * @param t The target time.
     */
    static void age_all_agents( Time t )
    {
        for ( auto agent : agents ) {
            agent->age_agent( t );
        }
    }


    /**
        * Finishes all agents.
        */

    static void finalize_all_agent_tables()
    {
        for (auto agent : agents) {
            agent->om_finalize_tables();
        }
    }

    /**
        * Move all agents from zombie lists to corresponding available list
        * The function definition is generated by the openM++ compiler.
        */

    static void free_all_zombies();

    /**
        * Adds the agent to the list of active agents
        */

    void make_active()
    {
        agents.push_front( this );
        iter_in_agents = agents.begin();
    }

    /**
        * Removes the agent from the list of active agents
        */
    
    void make_inactive()
    {
        agents.erase( iter_in_agents );
    }

    void om_Start_begin()
    {
        om_active = false;
        om_initialize_data_members();
        om_set_agent_id();
        om_initialize_expression_agentvars();
    }

    /**
        * Complete agent preparation for simulation
        */

    void om_Start_end()
    {
        om_initialize_tables();
        om_initialize_events();
        make_active();
        om_active = true;
    }

    /**
        * Remove agent from simulation.
        */

    void om_Finish_end()
    {
        om_finalize_tables();
        om_finalize_events();
        om_active = false;
        om_finalize_links();
        make_inactive();
        make_zombie();
    }


    /**
        * Number of active agents
        *
        * @return An int.
        */

    static int om_active_agents()
    {
        return agents.size();
    }

    /**
     * Gets the next agent identifier.
     * 
     * Used to set agent_id as part of the initialization of each agent. Returns the value 1 on the
     * first call.
     *
     * @return The next agent identifier.
     */
    static int get_next_agent_id()
    {
        static int counter = 0;
        return ++counter;
    }

    /**
     * True if agent is active in the simulation.
     */
    bool om_active;

    /**
     * The global time.
     */
    static Time global_time;

private:

    /**
        * The iterator of this agent in BaseAgent::agents.
        */

    list<BaseAgent *>::iterator iter_in_agents;


    /**
        * Active agents
        */

    static list<BaseAgent *> agents;


};

/**
    * Agent.
    * Only instances of derived classes of Agent are actually created.
    *
    * @tparam  A   Type of a.
    */

template<typename A>
class Agent : public BaseAgent
{
public:

    /**
        * Agent allocation operator.
        * This allocator recycles agents of the given type.
        * Note that the argument of new() is required for the correct
        * signature but is not required or used.
        *
        * @param   count   Size of object (required for correct signature)
        *
        * @return  The allocated object.
        */

    void *operator new( size_t count )
    {
		static bool first_invocation = true;
		A *agent = nullptr;
        if ( available.empty() ) {
			agent = ::new A;
            if ( first_invocation ) {
				// agentvar offsets and event offsets have fixed values,
				// so compute them only once, when the very first
				// instance of an agent of this type is created.
				agent->om_initialize_agentvar_offsets();
				agent->om_initialize_event_offsets();

                // Initialize the single static agent used to retrieve (zero) values
                // when dereferencing nullptr link agentvars.
                A::om_null_agent.om_initialize_data_members0();
				first_invocation = false;
			}
        }
        else {
            agent = available.front();
            available.pop_front();
        }

        return agent;
    }

    void make_zombie()
    {
        zombies.push_front( (A *)this );
    }

    /**
        * Free zombies.
        * Move all zombie agents to the available list
        * for re-use.
        */

    static void free_zombies()
    {
        while ( ! zombies.empty() ) {
            available.push_front( zombies.front() );
            zombies.pop_front();
        }
    }

    static forward_list<A *> zombies;
    static forward_list<A *> available;

};


/**
* Agent zombie list (definition)
*/

template<typename A>
forward_list<A *> Agent<A>::zombies;

/**
* Agent available list (definition)
*/

template<typename A>
forward_list<A *> Agent<A>::available;


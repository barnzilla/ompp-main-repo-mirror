actor Person
{
	logical spawning_done = { FALSE } ;
	event timeSpawnEvent, SpawnEvent;
};

link Thing.other_thing;
//link Thing.spawner Person.things[];
link Person.my_thing1 Thing.my_person1;
link Person.my_thing2 Thing.my_person2;
link Person.my_thing3 Thing.my_person3;

TIME Person::timeSpawnEvent()
{
	return spawning_done ? TIME_INFINITE : WAIT(0.0);
}

void Person::SpawnEvent()
{
	// Create things and add to simulation
	Thing *thing1 = new Thing;
	thing1->Start();

	Thing *thing2 = new Thing;
	thing2->Start();

    // retrieval test
    //link<Thing> a = thing1->other_thing;

    // if the following worked, just-in-time would fail.
    // We need to intercept pointer references, that's the whol idea.
    // But tha means that mechanical changes in Modgne models may be required.
    // 
    //Thing *b = thing1->other_thing;

	// Link Person to thing1 and thing2
	my_thing1 = thing1;
	my_thing2 = thing2;

	// link thing1 and thing2
	thing1->other_thing = thing2;

	//// populate multi-link of things
	//things->Add(thing1);
	//things->Add(thing2);

	spawning_done = TRUE;
}

actor Thing {
	logical alive = {TRUE};
	logical making_trouble = { TRUE };

	void Start();
	void Finish();

	event timeBeingGoodEvent, BeingGoodEvent;
	event timeMortalityEvent, MortalityEvent;
};


void Thing::Start()
{
}

void Thing::Finish()
{
}

TIME Thing::timeBeingGoodEvent()
{
	return making_trouble ? WAIT(10 * RandUniform(5)) : TIME_INFINITE;
}

void Thing::BeingGoodEvent()
{
	making_trouble = FALSE;
}

TIME Thing::timeMortalityEvent()
{
	TIME tEventTime = TIME_INFINITE;
	tEventTime = WAIT( - TIME( log( RandUniform(4) ) / MortalityHazard ) );
	//tEventTime = WAIT( 50 );
	return tEventTime;
}

void Thing::MortalityEvent()
{
	alive = FALSE;
	Finish();
}


//
//table Person z01
//{
//	{
//		duration()
//	}
//    * first_30_agent_ids
//    * thing1_good
//};

//range RNG_M_N { 200, 300 };
//actor Person
//{
//    RNG_M_N some_agent_ids = actor_id;
//};
//actor Thing
//{
//    RNG_M_N some_agent_ids = actor_id;
//};
//table Person zzz
//[ actor_id >= 300 && actor_id <= 325 && !thing1_good ]
//{
//	{
//		duration()
//	}
//};

//table Person z01b
//[ !thing1_good ]
//{
//    some_agent_ids
//	* {
//		duration()
//	}
//};

//table Person z02
//[ actor_id == 322 ]
//{
//    thing1_good
//	* {
//		duration()
//	}
//};

table Thing LinkTest1
{
	{
		duration() //EN Thing-years decimals=5
	}
	* making_trouble
};

actor Person
{
	logical thing1_good = ! my_thing1->making_trouble; //EN Thing1 good
	logical thing2_good = ! my_thing2->making_trouble; //EN Thing2 good
};
table Person LinkTest2
{
	{
		duration()  //EN Person-years decimals=5
	}
	* thing1_good
	* thing2_good
};

actor Thing
{
    logical both_alive = alive && other_thing->alive; //EN Both things alive
    logical good = !making_trouble; //EN Being good
    logical other_good = !other_thing->making_trouble; //EN Other being good
};
table Thing LinkTest3
[ both_alive ]
{
	{
		duration()  //EN Thing-years decimals=5
	}
    * good
    * other_good
};

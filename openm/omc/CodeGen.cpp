/**
 * @file    CodeGen.cpp
 * Implements the code generation class.
 */
// Copyright (c) 2013 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

#include <iostream>
#include <fstream>
#include <algorithm>
#include <utility>
#include <typeinfo>
#include "CodeGen.h"
#include "CodeBlock.h"
#include "ast.h"
#include "libopenm/db/modelBuilder.h"

using namespace std;
using namespace openm;

void CodeGen::do_all()
{
    CodeBlock t;
    CodeBlock h;
    CodeBlock c;

	do_preamble(t, h, c);
    do_model_name(h, c);
    do_time_stamp(h, c);

   	t += "namespace mm {";
   	h += "namespace mm {";
    c += "namespace mm {";

	do_types(t, c);
	do_parameters(h, c);
	do_tables(h, c);
	do_agents(h, c);
    do_event_queue(h, c);

	t += "} // namespace mm";
	h += "} // namespace mm";
	c += "} // namespace mm";

    do_ModelStartup(h, c);
    do_RunModel(h, c);
    do_ModelShutdown(h, c);
    do_API_entries(h, c);

    *oat << t;
    *oah << h;
    *oac << c;
}

void CodeGen::do_preamble( CodeBlock& t, CodeBlock& h, CodeBlock& c )
{
	Symbol *s = Symbol::find_a_symbol( typeid(ModelSymbol) );

    t += doxygen(
                "@file   om_types.h",
                "Declarations for " + s->name + " (generated by openM++ compiler)."
                );
    t += "" ;
	t += "#pragma once";
	t += "";

    h += doxygen(
                "@file   om_agents.h",
                "Declarations for " + s->name + " (generated by openM++ compiler)."
                );
    h += "" ;
	h += "#pragma once";
	h += "";
	h += "using namespace std;";
	h += "";
	h += "#include \"libopenm/omModel.h\"";
	h += "#include \"omc/omSimulation.h\"";
	h += "";

    c += doxygen(
                "@file   om_agents.cpp",
                "Definitions for " + s->name + " (generated by openM++ compiler)."
                );
	c += "";
	c += "#include \"om_agents.h\"";
	c += "#include \"omc/Agent.cpp\" // defines for Agent static template members";
	c += "#include \"omc/AgentVar.cpp\" // defines for AgentVar static members";
	c += "#include \"omc/Event.cpp\" // defines for Event static members";
	c += "";
	c += "using namespace openm;";
	c += "";
}

void CodeGen::do_model_name( CodeBlock& h, CodeBlock& c )
{
	Symbol *s = Symbol::find_a_symbol( typeid(ModelSymbol) );
	c += "// model identification" ;
	c += "const char * OM_MODEL_NAME =\"" + s->name + "\";" ;
	c += "" ;
    metaRows.modelDic.name = s->name;
}

void CodeGen::do_time_stamp( CodeBlock& h, CodeBlock& c )
{
    using namespace openm;
	c += "// model time stamp" ;
	c += "const char * OM_MODEL_TIMESTAMP = \"" + modelTimeStamp + "\";" ;
	c += "" ;
    metaRows.modelDic.timestamp = modelTimeStamp;
}

void CodeGen::do_types( CodeBlock& t, CodeBlock& c )
{
    // om_types.h - types declaration
    t += "// types";
    for (auto type : Symbol::pp_types) {
        t += type->cxx_declaration_global();
    }
    t += "";

    // om_agents.cpp - types definitions
    c += "// types";
    for (auto type : Symbol::pp_types) {
        c += type->cxx_definition_global();
    }
    c += "";

}

void CodeGen::do_parameters( CodeBlock& h, CodeBlock& c )
{
	// agents.h - parameter declaration
	h += "// model parameters";
    for ( auto parameter : Symbol::pp_parameters ) {
        h += parameter->cxx_declaration_global();
    }
	h += "";

	// agents.cpp - parameter definition
	c += "// model parameters";
    for ( auto parameter : Symbol::pp_parameters ) {
        c += parameter->cxx_definition_global();
    }
	c += "";

	// populate meta-data for parameters
    for ( auto parameter : Symbol::pp_parameters ) {
        parameter->populate_metadata(metaRows);
    }
}

void CodeGen::do_ModelStartup( CodeBlock& h, CodeBlock& c )
{
    c += "// Model startup method: initialize parameters";
	c += "void ModelStartup(IModel * i_model)";
	c += "{";
	c += "using namespace mm;";
	c += "// load model parameters";
	c += "theLog->logMsg(\"Reading Parameters\");";
    for ( auto parameter : Symbol::pp_parameters ) {
        string name = parameter->name;
    	string typ = Symbol::token_to_string( parameter->type );
    	//c += "try {";
	    c += "i_model->readParameter(\"" + name + "\", typeid(" + typ + "),  1, &" + name + ");";
        //c += "}";
	    //c += "catch(...)";
        //c += "{";
        //c += "// ignore";
        //c += "}";
    }
	c += "}";
	c += "";
}

void CodeGen::do_ModelShutdown( CodeBlock& h, CodeBlock& c )
{
	c += "// Model shutdown method: write output tables";
	c += "void ModelShutdown(IModel * i_model)";
	c += "{";
	c += "using namespace mm;";
	c += "// write output result tables";
	c += "theLog->logMsg(\"Writing Output Tables\");";
    for ( auto table : Symbol::pp_tables ) {
	    c += "the" + table->name + ".compute_expressions();";
    }
    for ( auto table : Symbol::pp_tables ) {
    	//c += "try {";
	    c += "i_model->writeOutputTable( \"" + table->name + "\", the" + table->name + ".n_accumulators, 1, const_cast<const double **>(the" + table->name + ".accumulators) );";
        //c += "}";
	    //c += "catch(...)";
        //c += "{";
        //c += "// ignore";
        //c += "}";
    }
    c += "}";
	c += "";
}

void CodeGen::do_agents( CodeBlock& h, CodeBlock& c )
{
    for ( auto agent : Symbol::pp_agents ) {

	    // agents.h
	    h += "// model agents";
        // e.g. class Person : public Agent<Person>
	    h += "class " + agent->name + " : public Agent<" + agent->name + ">";
        h += "{";
	    h += "public:";

        // Declarations and associated definitions of members used by auxiliary classes & templates
        // The C++ compiler needs these to successfully expand the template for Event, which needs to access
        // the agent member functions with fixed names.
        // They need to be declared before being used in Event class code.
        h += "int get_agent_id() const;";
        c += "";
        c += "int " + agent->name + "::get_agent_id() const";
        c += "{";
        c += "return agent_id.get();";
        c += "}";
        c += "";

        // the member age_agent for event management
        // TODO - add doxygen for generated code.
        h += "void age_agent( Time t );";
        c += "";
        c += "void " + agent->name + "::age_agent( Time t )";
        c += "{";
        c += "time.set( t );";
        c += "}";
        c += "";

        // iterate all agent events in agent
	    h += "// agent events";
        for ( auto ae : agent->pp_agentevents ) {
            h += ae->cxx_declaration_agent();
        }
	    h += "";

	    h += "// agent data members";
        // iterate all agent data members in agent
        for ( auto data_member : agent->pp_agent_data_members ) {
            h += data_member->cxx_declaration_agent();
            c += data_member->cxx_definition_agent();
        }
	    h += "";

        // iterate all tables in agent
	    h += "// tables in agent";
        for ( auto table : agent->pp_agent_tables ) {
            // declaration of agent scope members
            h += table->cxx_declaration_agent();
            // definition
            c += table->cxx_definition_agent();
	    }
	    h += "";
	    c += "";

	    // member functions with fixed names
	    h += "// member functions with fixed names";
        h += "void initialize_agentvar_offsets(); // generated by openM++ compiler";
        h += "void initialize_event_offsets(); // generated by openM++ compiler";
        h += "void initialize_data_members(); // generated by openM++ compiler";
        h += "void initialize_agent_tables(); // generated by openM++ compiler";
        h += "void initialize_agent_events(); // generated by openM++ compiler";
        h += "void finalize_agent_tables(); // generated by openM++ compiler";
        h += "void finalize_agent_events(); // generated by openM++ compiler";
        h += "void om_Start_custom(); // defined in model code";
	    h += "void om_Finish_custom(); // defined in model code";
	    h += "void Start()";
	    h += "{";
	    h += "om_Start_begin();";
	    h += "om_Start_custom();";
	    h += "om_Start_end();";
        h += "}";
	    h += "void Finish()";
	    h += "{";
	    h += "om_Finish_custom();";
	    h += "om_Finish_end();";
	    h += "}";

	    h += "";

	    h += "}; // class " + agent->name + "";
	    h += "";

	    c += "";
        c += "// One-time initialization of agentvar offsets";
        c += "void " + agent->name + "::initialize_agentvar_offsets()";
        c += "{";
        for ( auto av : agent->pp_agentvars ) {
            // e.g. age.offset_in_agent = (char *)&(this->age) - (char *)this;
            c += av->name + ".offset_in_agent = (char *)&(this->" + av->name + ") - (char *)this;" ;
        }
        c += "}";

	    c += "";
        c += "// One-time initialization of event offsets";
        c += "void " + agent->name + "::initialize_event_offsets()";
        c += "{";
        for ( auto aet : agent->pp_agent_event_times ) {
            // e.g. om_time_MortalityEvent.offset_in_agent = (char *)&(this->om_time_MortalityEvent) - (char *)this;
            c += aet->name + ".offset_in_agent = (char *)&(this->" + aet->name + ") - (char *)this;" ;
        }
        c += "}";

	    c += "";
        c += "// Initialize all agent data members";
        c += "void " + agent->name + "::initialize_data_members()";
        c += "{";
        for ( auto adm : agent->pp_agent_data_members ) {
            c += adm->cxx_initialize_expression();
        }
        c += "}";

        c += "";
        c += "// Initialize tabulation-related data members";
        c += "void " + agent->name + "::initialize_agent_tables()";
        c += "{";
        for ( auto table : agent->pp_tables ) {
            c += table->do_increments_func() + "(true, false);";
        }
        c += "}";

	    c += "";
        c += "// Finalize tabulation-related operations";
        c += "void " + agent->name + "::finalize_agent_tables()";
        c += "{";
        for ( auto table : agent->pp_tables ) {
            c += table->do_increments_func() + "(false, true);";
        }
        c += "}";

	    c += "";
        c += "// Initialize events";
        c += "void " + agent->name + "::initialize_agent_events()";
        c += "{";
        for ( auto event_time : agent->pp_agent_event_times ) {
            c += event_time->name + ".make_dirty();";
        }
        c += "}";

	    c += "";
        c += "// Finalize events";
        c += "void " + agent->name + "::finalize_agent_events()";
        c += "{";
        for ( auto event_time : agent->pp_agent_event_times ) {
            c += event_time->name + ".make_zombie();";
        }
        c += "}";
    }

    c += doxygen("Free all zombie agents");
    c += "void BaseAgent::free_all_zombies()";
    c += "{";
    for ( auto agent : Symbol::pp_agents ) {
        // e.g. Person::free_zombies();
        c += agent->name + "::free_zombies();";
    }
    c += "}";

}

void CodeGen::do_tables( CodeBlock& h, CodeBlock& c )
{
	h += "// model output tables";
	c += "// model output tables";

	for ( auto table : Symbol::pp_tables ) {
        h += table->cxx_declaration_global();
        c += table->cxx_definition_global();
        table->populate_metadata(metaRows);
    }

	h += "";
	c += "";
}

void CodeGen::do_event_queue( CodeBlock& h, CodeBlock& c )
{
    c += doxygen( "The event queue (definition)" );
    c += "set<BaseEvent *, less_deref<BaseEvent *> > BaseEvent::event_queue;";
    c += doxygen( "The dirty event list (definition)" );
    c += "tailed_forward_list<BaseEvent *> BaseEvent::dirty_events;";
    c += doxygen( "The active agent list (definition)" );
    c += "list<BaseAgent *> BaseAgent::agents;";
    c += "";
}


void CodeGen::do_RunModel( CodeBlock& h, CodeBlock& c )
{
	// agents.cpp
	c += "// Model simulation (implemented in simulation.cpp for prototype)";
	c += "extern void RunModel(IModel * i_model);";
}


void CodeGen::do_API_entries( CodeBlock& h, CodeBlock& c )
{
	// agents.cpp
	c.smart_indenting ( false );
	c += "namespace openm";
	c += "{";
	c += "    // model API entries holder";
	c += "    struct ModelEntryHolder";
	c += "    {";
	c += "        ModelEntryHolder(";
	c += "            OM_STARTUP_HANDLER i_ModelStartupHandler,";
	c += "            OM_EVENT_LOOP_HANDLER i_RunModelHandler,";
	c += "            OM_SHUTDOWN_HANDLER i_ModelShutdownHandler";
	c += "            ) ";
	c += "        { ";
	c += "            ::ModelStartupHandler = i_ModelStartupHandler;    // link model startup function";
	c += "            ::RunModelHandler = i_RunModelHandler;            // link user portion of model event loop";
	c += "            ::ModelShutdownHandler = i_ModelShutdownHandler;  // link model shutdown function";
	c += "        }";
	c += "    };";
	c += "";
	c += "    // set entry points to the code generated by openM++ compiler";
	c += "    static ModelEntryHolder theModelEntry(::ModelStartup, ::RunModel, ::ModelShutdown);";
	c += "}";
	c += "";
	c.smart_indenting ( true );
}
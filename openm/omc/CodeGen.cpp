/**
 * @file    CodeGen.cpp
 * Implements the code generation class.
 */
// Copyright (c) 2013-2014 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

#include <iostream>
#include <fstream>
#include <algorithm>
#include <utility>
#include <typeinfo>
#include "CodeGen.h"
#include "CodeBlock.h"
#include "ast.h"
#include "libopenm/db/modelBuilder.h"

using namespace std;
using namespace openm;

void CodeGen::do_all()
{
	do_preamble();

	do_types();
	do_aggregations();
	do_parameters();
	do_entity_tables();
	do_derived_tables();
	do_table_interface();
	do_agents();
	do_entity_sets();
    do_event_queue();

    h += "void StartSimulation(int id);";
    h += "void EndSimulation();";

    do_RunInit();
    do_ModelStartup();
    do_RunModel();
    do_ModelShutdown();
    do_API_entries();

    *oat0 << t0;
    *oat1 << t1;
    *oah << h;
    *oac << c;
    *oaz << z;
}

void CodeGen::do_preamble()
{
    // Get the model symbol
    ModelSymbol *model_symbol = dynamic_cast<ModelSymbol *>(Symbol::find_a_symbol(typeid(ModelSymbol)));
    assert(model_symbol);
    model_symbol->time_stamp = time_stamp;
    model_symbol->populate_metadata(metaRows);

    model_symbol->model_digest = model_symbol->metadata_digest();

    // Get the model_type symbol
    ModelTypeSymbol *model_type_symbol = dynamic_cast<ModelTypeSymbol *>(Symbol::find_a_symbol(typeid(ModelTypeSymbol)));
    assert(model_type_symbol);
    model_type_symbol->populate_metadata(metaRows);

    // Get the version symbol
    VersionSymbol *version_symbol = dynamic_cast<VersionSymbol *>(Symbol::find_a_symbol(typeid(VersionSymbol)));
    assert(version_symbol);
    version_symbol->populate_metadata(metaRows);

    // common elements of all file headers
    string model_str = " for model '" + model_symbol->name + "' - Generated by openM++ compiler";
    string version_str = " Model version = " + version_symbol->formatted_value();
    string timestamp_str = " Model timestamp = " + model_symbol->time_stamp;
    string digest_str = " Model parameter digest = " + model_symbol->model_digest;

    // om_types0.h
    t0 += doxygen(
                "@file   om_types0.h",
                "Fundamental types" + model_str,
                " ",
                version_str,
                timestamp_str,
                digest_str
        );
    t0 += "";
    t0 += "#pragma once";
    t0 += "#include <cmath>";
    t0 += "#include \"omc/fixed_precision_float.h\"";
    t0 += "";

    // om_types1.h
    t1 += doxygen(
                "@file   om_types1.h",
                "Types" + model_str,
                " ",
                version_str,
                timestamp_str,
                digest_str
                );
    t1 += "" ;
	t1 += "#pragma once";
    t1 += "#include \"om_types0.h\"";
    t1 += "#include \"omc/Range.h\"";
    t1 += "#include \"omc/Partition.h\"";
    t1 += "#include \"omc/Classification.h\"";
    t1 += "";

    // om_declarations.h
    h += doxygen(
                "Declarations" + model_str,
                " ",
                version_str,
                timestamp_str,
                digest_str
                );
    h += "" ;
	h += "#pragma once";
	h += "#include \"omc/omSimulation.h\"";
	h += "#include \"custom.h\" // model-specific header file";
    h += "";
    h += "using namespace std;";
    h += "";

    if (Symbol::pre_simulation_count > 0) {
        h += "// pre-simulation functions from model source code";
        for (int id = 0; id < Symbol::pre_simulation_count; ++id) {
            h += "extern void " + Symbol::pre_simulation_name(id) + "();";
        }
        h += "";
    }

    if (Symbol::post_simulation_count > 0) {
        h += "// post-simulation functions from model source code";
        for (int id = 0; id < Symbol::post_simulation_count; ++id) {
            h += "extern void " + Symbol::post_simulation_name(id) + "();";
        }
        h += "";
    }


    // om_definitions.cpp
    c += doxygen(
                "@file   om_definitions.cpp",
                "Definitions" + model_str,
                " ",
                version_str,
                timestamp_str,
                digest_str
                );
	c += "";
    c += "#include <cassert>";
    c += "#include <typeinfo>";
    c += "#include \"omc/omSimulation.h\"";
    c += "";

    // Get definition code associated with the model_type symbol
    c += model_type_symbol->cxx_definition_global();
    c += "";

    // Get definition code associated with the model symbol (name, time stamp)
    c += model_symbol->cxx_definition_global();
    c += "";

	c += "using namespace openm;";
	c += "";

    if (Symbol::option_event_trace) {
        // Let the run-time know if trace event is enabled
        c += "const bool BaseEvent::trace_event_enabled = true;";
        // if event_trace option is on, tracing is active unless turned off
        c += "thread_local bool BaseEvent::trace_event_on = true;";
    }
    else {
        // Let the run-time know if trace event is enabled
        c += "const bool BaseEvent::trace_event_enabled = false;";
        // independent of the event_trace option, this static member must be defined
        c += "thread_local bool BaseEvent::trace_event_on = false;";
    }

    // Let the run-time know whether to generate a running checksum for events
    if (Symbol::option_case_checksum) {
        c += "const bool BaseEvent::event_checksum_enabled = true;";
    }
    else {
        c += "const bool BaseEvent::event_checksum_enabled = false;";
    }
    // The checksum must be defined in any case
    c += "thread_local double BaseEvent::event_checksum_value = 0.0;";

    c += "";

    // om_initializers.cpp
    z += doxygen(
                "@file   om_fixed_parms.cpp",
                "Definitions for fixed parameters for model '" + model_symbol->name + "' - Generated by openM++ compiler",
                " ",
                " Model version = " + version_symbol->formatted_value(),
                " Time stamp = " + model_symbol->time_stamp
                );
	z += "";
    z += "#include \"omc/cumrate.h\"";
    z += "#include \"om_types1.h\"";
	z += "";

}

void CodeGen::do_types()
{
    // om_types0.h - fundamental types declaration
    t0 += "// fundamental types";
    for (auto type : Symbol::pp_all_types0) {
        t0 += type->cxx_declaration_global();
    }
    t0 += "";

    // om_types1.h - templated types declaration
    t1 += "// templated types";
    for (auto type : Symbol::pp_all_types1) {
        t1 += type->cxx_declaration_global();
    }
    t1 += "";

    // om_definitions.cpp - types definitions
    c += "// fundamental types";
    for (auto type : Symbol::pp_all_types0) {
        c += type->cxx_definition_global();
    }
    c += "";

    c += "// templated types";
    for (auto type : Symbol::pp_all_types1) {
        c += type->cxx_definition_global();
    }
    c += "";

    // populate meta-data for types
    for (auto type : Symbol::pp_all_types0) {
        type->populate_metadata(metaRows);
    }
    for (auto type : Symbol::pp_all_types1) {
        type->populate_metadata(metaRows);
    }
}

void CodeGen::do_aggregations()
{
    if (Symbol::pp_all_aggregations.empty()) return;

    // parameter declarations
	h += "// model aggregations";
	c += "// model aggregations";
    for ( auto aggregation : Symbol::pp_all_aggregations ) {
        h += aggregation->cxx_declaration_global();
        c += aggregation->cxx_definition_global();
    }
	h += "";
	c += "";
}

void CodeGen::do_parameters()
{
	// parameter declarations
	h += "// model parameters";
    for ( auto parameter : Symbol::pp_all_parameters ) {
        h += parameter->cxx_declaration_global();
        if (parameter->cumrate) {
            h += parameter->lookup_fn->cxx_declaration_global();
        }
    }
	h += "";

	// parameter definitions & initializers
	c += "// model parameters (scenario, derived, missing)";
	z += "// model parameters (fixed)";
    for (auto parameter : Symbol::pp_all_parameters) {
        if (parameter->source == ParameterSymbol::fixed_parameter) {
            // place definition (with initializer) in the cpp module for fixed parameters
            z += parameter->cxx_definition_global();
        }
        else {
            c += parameter->cxx_definition_global();
        }
        if (parameter->cumrate) {
            c += parameter->lookup_fn->cxx_definition_global();
        }
    }
	c += "";

	// populate meta-data for parameters
    for ( auto parameter : Symbol::pp_all_parameters ) {
        parameter->populate_metadata(metaRows);
    }
}

void CodeGen::do_RunInit()
{
    c += "// Model run initialization";
	c += "void RunInit(IRunInit * const i_runInit)";
	c += "{";

    c += "// Agent static initialization part 1: Initialize agent member offsets & null agent data members";
    for (auto agent : Symbol::pp_all_agents) {
        c += "// Agent - " + agent->name;
        c += agent->name + "::om_null_agent.om_assign_attribute_offsets();";
        c += agent->name + "::om_null_agent.om_initialize_data_members0();";
        c += "";
    }

    c += "// Agent static initialization part 2: Initialize null agent dependent agentvars";
    for (auto agent : Symbol::pp_all_agents) {
        c += "// Agent - " + agent->name;
        c += agent->name + "::om_null_agent.om_initialize_identity_attributes();";
        c += agent->name + "::om_null_agent.om_initialize_derived_attributes();";
        c += agent->name + "::om_null_agent.om_reset_derived_attributes();";
    }
    c += "";

    c += "// Sanity type check of storage type and readParameters type argument";
    for (auto parameter : Symbol::pp_all_parameters) {
        c += parameter->cxx_assert_sanity();
    }
    c += "";

    c += "theLog->logMsg(\"Reading Parameters\");";
    for (auto parameter : Symbol::pp_all_parameters) {
        if (parameter->source == ParameterSymbol::derived_parameter) continue;
        if (parameter->source == ParameterSymbol::scenario_parameter) {
            c += parameter->cxx_read_parameter();
        }
        else if (parameter->source == ParameterSymbol::missing_parameter) {
            c += "theLog->logFormatted(\"warning - no values supplied for parameter " + parameter->name + "\");";
        }
        if (parameter->cumrate) {
            // prepare cumrate for fixed, scenario, and missing parameters
            c += parameter->cxx_initialize_cumrate();
        }
        if (parameter->haz1rate) {
            // perform haz1rate transformation
            c += parameter->cxx_transform_haz1rate();
        }
    }
    c += "";

    if (Symbol::pre_simulation_count > 0) {
        c += "theLog->logMsg(\"Running pre-simulation\");";
        for (int id = 0; id < Symbol::pre_simulation_count; ++id) {
            c += Symbol::pre_simulation_name(id) + "();";
        }
        for (auto parameter : Symbol::pp_all_parameters) {
            if (parameter->source == ParameterSymbol::derived_parameter) {
                if (parameter->cumrate) {
                    // prepare cumrate for derived parameters after all pre-simulation code has executed
                    c += parameter->cxx_initialize_cumrate();
                }
                if (parameter->haz1rate) {
                    // perform haz1rate transformation
                    c += parameter->cxx_transform_haz1rate();
                }
            }
        }
    }

	c += "}";
	c += "";
}

void CodeGen::do_ModelStartup()
{
    c += "// Model startup method: Initialization for a simulation thread";
    c += "void ModelStartup(IModel * const i_model)";
    c += "{";

    c += "// Entity table instantiation";
    for (auto et : Symbol::pp_all_entity_tables) {
        c += "assert(!" + et->cxx_instance + "); ";
        c += et->cxx_instance + " = new " + et->cxx_type + "(" + et->cxx_initializer() + ");";
    }
    c += "";

    c += "// Derived table instantiation";
    for (auto dt : Symbol::pp_all_derived_tables) {
        c += "assert(!" + dt->cxx_instance + "); ";
        c += dt->cxx_instance + " = new " + dt->cxx_type + "(" + dt->cxx_initializer() + ");";
    }
    c += "";

    c += "// Entity set instantiation";
    for (auto es : Symbol::pp_all_entity_sets) {
        c += "{";
        if (es->dimension_count() == 0) {
            c += "assert(!" + es->name + ");";
            c += es->name + " = new EntitySet<" + es->pp_agent->name + ">;";
        }
        else {
            c += "EntitySet<" + es->pp_agent->name + "> ** flattened_array = reinterpret_cast<EntitySet<" + es->pp_agent->name + "> **>(" + es->name + ");";
            c += "const size_t cells = " + to_string(es->cell_count()) + ";";
            c += "for (size_t cell = 0; cell < cells; ++cell) {";
            c += "assert(!flattened_array[cell]);";
            c += "flattened_array[cell] = new EntitySet<" + es->pp_agent->name + ">;";
            c += "}";
        }
        c += "}";
    }
    c += "";

    c += "}";
    c += "";
}

void CodeGen::do_ModelShutdown()
{
	c += "// Model shutdown method: outputs";
	c += "void ModelShutdown(IModel * const i_model)";
	c += "{";
    c += "// extract accumulators, and scale them to population size";
    for ( auto table : Symbol::pp_all_entity_tables ) {
	    c += "the" + table->name + "->extract_accumulators();";
	    c += "the" + table->name + "->scale_accumulators();";
    }
	c += "";

    c += "// compute table expressions using accumulators";
    for ( auto table : Symbol::pp_all_entity_tables ) {
	    c += "the" + table->name + "->compute_expressions();";
    }
	c += "";

    if (Symbol::post_simulation_count > 0) {
        c += "theLog->logMsg(\"Running post-simulation\");";
        for (int id = 0; id < Symbol::post_simulation_count; ++id) {
            c += Symbol::post_simulation_name(id) + "();";
        }
    	c += "";
    }

	c += "theLog->logMsg(\"Writing Output Tables\");";
    c += "// write entity tables (accumulators)";
    for ( auto table : Symbol::pp_all_entity_tables ) {
        c += "{";
        c += "const char *name = \"" + table->name + "\";";
        c += "auto &tbl = the" + table->name + ";";
        c += "double *pdbl[tbl->n_accumulators]; // array of pointers for writeOutputTable";
        c += "for (size_t j = 0; j < tbl->n_accumulators; ++j) pdbl[j] = tbl->acc[j];";
	    c += "i_model->writeOutputTable(name, tbl->n_accumulators, tbl->n_cells, const_cast<const double **>(pdbl));";
        c += "}";
    }

    c += "// write derived tables (measures)";
    for ( auto derived_table : Symbol::pp_all_derived_tables ) {
        c += "{";
        c += "const char *name = \"" + derived_table->name + "\";";
        c += "auto &tbl = " + derived_table->cxx_instance + ";";
        c += "double *pdbl[tbl->n_measures]; // array of pointers for writeOutputTable";
        c += "for (size_t j = 0; j < tbl->n_measures; ++j) pdbl[j] = tbl->measure[j];";
	    c += "i_model->writeOutputTable(name, tbl->n_measures, tbl->n_cells, const_cast<const double **>(pdbl));";
        c += "}";
    }

    c += "// Entity table destruction";
    for (auto table : Symbol::pp_all_entity_tables) {
        c += "assert(the" + table->name + "); ";
        c += "delete the" + table->name + ";";
        c += "the" + table->name + " = nullptr;";
    }
    c += "";

    c += "// Derived table destruction";
    for (auto derived_table : Symbol::pp_all_derived_tables) {
        c += "assert(" + derived_table->cxx_instance + "); ";
        c += "delete " + derived_table->cxx_instance + ";";
        c += derived_table->cxx_instance + " = nullptr;";
    }
    c += "";

    c += "// Entity set destruction";
    for (auto es : Symbol::pp_all_entity_sets) {
        c += "{";
        if (es->dimension_count() == 0) {
            c += "assert(" + es->name + ");";
            c += "delete(" + es->name + ");";
        }
        else {
            c += "EntitySet<" + es->pp_agent->name + "> ** flattened_array = reinterpret_cast<EntitySet<" + es->pp_agent->name + "> **>(" + es->name + ");";
            c += "const size_t cells = " + to_string(es->cell_count()) + ";";
            c += "for (size_t cell = 0; cell < cells; ++cell) {";
            c += "assert(flattened_array[cell]);";
            c += "delete flattened_array[cell];";
            c += "flattened_array[cell] = nullptr;";
            c += "}";
        }
        c += "}";
    }
    c += "";

    c += "}";
	c += "";
}

void CodeGen::do_agents()
{
	h += "// forward declarations of model agent classes (for links)";
    for (auto agent : Symbol::pp_all_agents) {
        h += "class " + agent->name + ";";
    }
    h += "";
    for ( auto agent : Symbol::pp_all_agents ) {

	    h += "// model agent classes";
        // e.g. class Person : public Agent<Person>
	    h += "class " + agent->name + " : public Agent<" + agent->name + ">";
        h += "{";
	    h += "public:";

	    h += "";
	    h += "//";
	    h += "// function members in " + agent->name + " agent";
	    h += "//";
	    h += "";

	    h += "// operator overload for entity comparison based on entity_id";
        h += "bool operator< ( " + agent->name + " & rhs )";
        h += "{";
        h += "return entity_id < rhs.entity_id;";
        h += "}";
	    h += "";

        for ( auto func_member : agent->pp_agent_funcs ) {
            h += func_member->cxx_declaration_agent();
            c += func_member->cxx_definition_agent();
        }

	    h += "";
	    h += "//";
	    h += "// data members in " + agent->name + " agent";
	    h += "//";
	    h += "";
        for ( auto data_member : agent->pp_agent_data_members ) {
            h += data_member->cxx_declaration_agent();
            c += data_member->cxx_definition_agent();
        }
	    h += "";
	    c += "";

        h += "// The declaration of the single static " + agent->name;
        h += "// used to retrieve (zero) values when dereferencing nullptr link agentvars.";
        h += "static " + agent->name + " " + "om_null_agent;";

	    h += "}; // class " + agent->name;
	    h += "";

        c += "// The definition of the single static " + agent->name;
        c += "// used to retrieve (zero) values when dereferencing nullptr link agentvars.";
        c += agent->name + " " + agent->name + "::om_null_agent;";
    }

    c += doxygen("Free all zombie agents");
    c += "void BaseAgent::free_all_zombies()";
    c += "{";
    for ( auto agent : Symbol::pp_all_agents ) {
        // e.g. Person::free_zombies();
        c += agent->name + "::free_zombies();";
    }
    c += "}";
    c += "";

    c += "void BaseAgent::initialize_simulation_runtime()";
    c += "{";
    c += "agents = new list<BaseAgent *>;";
    for ( auto agent : Symbol::pp_all_agents ) {
        // e.g. Person::zombies = new forward_list<Person *>;";
        c += agent->name + "::zombies = new forward_list<" + agent->name + " *>;";
        c += agent->name + "::available = new forward_list<" + agent->name + " *>;";
    }
    c += "}";
    c += "";

    c += "void BaseAgent::finalize_simulation_runtime()";
    c += "{";
    c += "delete agents;";
    c += "agents = nullptr;";
    for ( auto agent : Symbol::pp_all_agents ) {
        c += "delete " + agent->name + "::zombies;";
        c += agent->name + "::zombies = nullptr;";
        c += "delete " + agent->name + "::available;";
        c += agent->name + "::available = nullptr;";
    }
    c += "}";
    c += "";
}

void CodeGen::do_entity_sets()
{
    if (Symbol::pp_all_entity_sets.size() > 0) {
	    h += "// entity sets";
	    c += "// entity sets";

	    for ( auto es : Symbol::pp_all_entity_sets ) {
            h += es->cxx_declaration_global();
            c += es->cxx_definition_global();
        }

	    h += "";
	    c += "";
    }
}

void CodeGen::do_entity_tables()
{
	h += "// entity tables";
	c += "// entity tables";

	for ( auto table : Symbol::pp_all_entity_tables ) {
        h += table->cxx_declaration_global();
        c += table->cxx_definition_global();
        table->populate_metadata(metaRows);
    }
}

void CodeGen::do_derived_tables()
{
	h += "// derived tables";
	c += "// derived tables";

	for ( auto derived_table : Symbol::pp_all_derived_tables ) {
        h += derived_table->cxx_declaration_global();
        c += derived_table->cxx_definition_global();
        derived_table->populate_metadata(metaRows);
    }

    h += "";
	c += "";
}

void CodeGen::do_table_interface()
{
    // om_table_measure (global object)
    h += "extern const map<string, pair<int, int>> om_table_measure;";
    c += doxygen(
        "Helper map for model developer table interface.",
        " ",
        "The key of the map is a string with the form table.measure.",
        "The value of the map is a pair containing the numeric table identifier",
        "and the numeric measure identifier within the table."
                 );
    c += "const map<string, pair<int, int>> om_table_measure = {";
    for (auto table : Symbol::pp_all_tables) {
        for (auto measure : table->pp_measures) {
            auto key = table->name + "." + measure->measure_name;
            auto table_id = to_string(table->pp_table_id);
            auto measure_id = to_string(measure->index);
            c += "{\"" + key + "\", {" + table_id + ", " + measure_id + "} },";
        }
    }
    c += "};";
    c += "";

    // om_get_table_measure_address (global function)
    h += "double * om_get_table_measure_address(int table_id, int measure_id, vector<int> indices);";
    c += doxygen("Get the address of a measure in a table");
    c += "double * om_get_table_measure_address(int table_id, int measure_id, vector<int> indices)";
    c += "{";
    c += "switch (table_id) {";
    for (auto table : Symbol::pp_all_tables) {
        c += "case " + to_string(table->pp_table_id) + ": return " + table->cxx_instance + "->get_measure_address(measure_id, indices);";
    }
    c += "default: assert(false); // logic guarantee";
    c += "}";
    c += "return nullptr;";
    c += "}";
    c += "";

	h += "// Interface to tables from model code";
    h += "";
    h += "template<typename ...Items>";
	h += "double GetTableValue(const string measure_name, Items... args)";
	h += "{";
    h += "vector<int> indices = {{ args ... }};";
    h += "// Work-around to VC++ converting empty parameter pack to initializer list of size 1 with element 0";
    h += "if (0 == sizeof...(Items)) indices.clear();";
    h += "auto it = om_table_measure.find(measure_name);";
    h += "if (it == om_table_measure.end()) {";
    h += "//TODO - run time error - invalid table.measure";
    h += "return 0.0;";
    h += "}";
    h += "auto pr = it->second;";
    h += "auto table_id = pr.first;";
    h += "auto measure_id = pr.second;";
    h += "double *address = om_get_table_measure_address(table_id, measure_id, indices);";
    h += "if (address != nullptr) {";
    h += "return *address;";
    h += "}";
    h += "else {";
    h += "return UNDEF_VALUE;";
    h += "}";
    h += "}";
    h += "";

    h += "template<typename ...Items>";
	h += "void SetTableValue(const string measure_name, double value, Items... args)";
	h += "{";
    h += "vector<int> indices = {{ args ... }};";
    h += "// Work-around to VC++ converting empty parameter pack to initializer list of size 1 with element 0";
    h += "if (0 == sizeof...(Items)) indices.clear();";
    h += "auto it = om_table_measure.find(measure_name);";
    h += "if (it == om_table_measure.end()) {";
    h += "//TODO - run time error - invalid table.measure";
    h += "}";
    h += "auto pr = it->second;";
    h += "auto table_id = pr.first;";
    h += "auto measure_id = pr.second;";
    h += "double *address = om_get_table_measure_address(table_id, measure_id, indices);";
    h += "if (address != nullptr) {";
    h += "*address = value;";
    h += "}";
    h += "else {";
    h += "//TODO - run time error";
    h += "}";
    h += "}";

    h += "";
	c += "";

}

void CodeGen::do_event_queue()
{
    c += "// definition of event_queue (declaration in Event.h)";
    c += "thread_local set<BaseEvent *, less_deref<BaseEvent *> > *BaseEvent::event_queue = nullptr;";
    c += "";
    c += "// definition of dirty_events (declaration in Event.h)";
    c += "thread_local tailed_forward_list<BaseEvent *> *BaseEvent::dirty_events = nullptr;";
    c += "";
    c += "// definition of global_event_counter (declaration in Event.h)";
    c += "thread_local big_counter BaseEvent::global_event_counter;";
    c += "";
    c += "// definition of global_time (declaration in Event.h)";
    c += "thread_local Time *BaseEvent::global_time = nullptr;";
    c += "";
    c += "// definition of active agent list (declaration in Agent.h)";
    c += "thread_local list<BaseAgent *> *BaseAgent::agents = nullptr;";
    c += "";
}


void CodeGen::do_RunModel()
{
	c += "// Model simulation";
	c += "void RunModel(IModel * const i_model)";
    c += "{";

    c += "// initialize entity tables";
	for ( auto table : Symbol::pp_all_entity_tables ) {
        c += "the" + table->name + "->initialize_accumulators();";
    }
    c += "";
    c += "BaseEvent::initialize_simulation_runtime();";
    c += "BaseAgent::initialize_simulation_runtime();";
    c += "";
    c += "int mem_id = i_model->subSampleNumber();";
    c += "int mem_count = i_model->subSampleCount();";
    c += "RunSimulation(mem_id, mem_count); // Defined by the model framework, generally in a 'use' module";
    c += "";
    c += "BaseEvent::finalize_simulation_runtime();";
    c += "BaseAgent::finalize_simulation_runtime();";
    c += "}";
    c += "";
}


void CodeGen::do_API_entries()
{
	c.smart_indenting ( false );
	c += "namespace openm";
	c += "{";
	c += "    // set entry points to the code generated by openM++ compiler";
	c += "    static ModelEntryHolder theModelEntry(::RunInit, ::ModelStartup, ::RunModel, ::ModelShutdown);";
	c += "}";
	c += "";
	c.smart_indenting ( true );
}
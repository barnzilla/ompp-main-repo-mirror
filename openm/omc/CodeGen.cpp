/**
 * @file    CodeGen.cpp
 * Implements the code generation class.
 */
// Copyright (c) 2013 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

#include <iostream>
#include <fstream>
#include <algorithm>
#include <utility>
#include <typeinfo>
#include "token.h"
#include "CodeGen.h"
#include "CodeBlock.h"
#include "ast.h"
#include "libopenm/db/modelBuilder.h"

using namespace std;
using namespace openm;

void CodeGen::do_all()
{
    CodeBlock t;
    CodeBlock h;
    CodeBlock c;

	do_preamble(t, h, c);
    do_model_name(h, c);
    do_time_stamp(h, c);

   	t += "namespace mm {";
   	h += "namespace mm {";
    c += "namespace mm {";

	do_types(t, c);
	do_parameters(h, c);
	do_tables(h, c);
	do_agents(h, c);
    do_event_queue(h, c);

	t += "} // namespace mm";
	h += "} // namespace mm";
	c += "} // namespace mm";

    do_ModelStartup(h, c);
    do_RunModel(h, c);
    do_ModelShutdown(h, c);
    do_API_entries(h, c);

    *oat << t;
    *oah << h;
    *oac << c;
}

void CodeGen::do_preamble( CodeBlock& t, CodeBlock& h, CodeBlock& c )
{
	Symbol *s = Symbol::find_a_symbol( typeid(ModelSymbol) );

    t += doxygen(
                "@file   om_types.h",
                "Declarations for " + s->name + " (generated by openM++ compiler)."
                );
    t += "" ;
	t += "#pragma once";
	t += "";

    h += doxygen(
                "@file   om_agents.h",
                "Declarations for " + s->name + " (generated by openM++ compiler)."
                );
    h += "" ;
	h += "#pragma once";
	h += "";
	h += "using namespace std;";
	h += "";
	h += "#include \"libopenm/omModel.h\"";
	h += "#include \"omc/omSimulation.h\"";
	h += "";

    c += doxygen(
                "@file   om_agents.cpp",
                "Definitions for " + s->name + " (generated by openM++ compiler)."
                );
	c += "";
	c += "#include \"om_agents.h\"";
	c += "#include \"omc/Agent.cpp\" // defines for Agent static template members";
	c += "#include \"omc/AgentVar.cpp\" // defines for AgentVar static members";
	c += "#include \"omc/Event.cpp\" // defines for Event static members";
	c += "";
	c += "using namespace openm;";
	c += "";
}

void CodeGen::do_model_name( CodeBlock& h, CodeBlock& c )
{
	Symbol *s = Symbol::find_a_symbol( typeid(ModelSymbol) );
	c += "// model identification" ;
	c += "const char * OM_MODEL_NAME =\"" + s->name + "\";" ;
	c += "" ;
    metaRows.modelDic.name = s->name;
}

void CodeGen::do_time_stamp( CodeBlock& h, CodeBlock& c )
{
    using namespace openm;
	c += "// model time stamp" ;
	c += "const char * OM_MODEL_TIMESTAMP = \"" + modelTimeStamp + "\";" ;
	c += "" ;
    metaRows.modelDic.timestamp = modelTimeStamp;
}

void CodeGen::do_types( CodeBlock& t, CodeBlock& c )
{
	t += "// types";
	c += "// types";

    {
	    auto *sym = dynamic_cast<TypeDeclSymbol *>( Symbol::get_symbol( token_to_string( token::TK_Time ) ) );
        assert ( sym ); // compiler guarantee
	    string typ = token_to_string( sym->value );
        // E.g. typedef double Time;
	    t += "typedef " + typ + " " + sym->name + ";";
	    t += "typedef " + typ + " TIME; // for Modgen models";

	    // Time 'literals'
	    t += "extern const Time time_infinite;";
	    t += "extern const Time TIME_INFINITE; // for Modgen models";
	    t += "";
	    c += "const Time time_infinite = 32767;";
	    c += "const Time TIME_INFINITE = 32767; // for Modgen models";
	    c += "";
    }

    {
	    auto *sym = dynamic_cast<TypeDeclSymbol *>( Symbol::get_symbol( token_to_string( token::TK_real ) ) );
        assert ( sym ); // compiler guarantee
	    string typ = token_to_string( sym->value );
        // E.g. typedef double real;
	    t += "typedef " + typ + " " + sym->name + ";";
    }

    {
	    auto *sym = dynamic_cast<TypeDeclSymbol *>( Symbol::get_symbol( token_to_string( token::TK_counter ) ) );
        assert ( sym ); // compiler guarantee
	    string typ = token_to_string( sym->value );
        // E.g. typedef uint counter;
	    t += "typedef " + typ + " " + sym->name + ";";
    }

    {
	    auto *sym = dynamic_cast<TypeDeclSymbol *>( Symbol::get_symbol( token_to_string( token::TK_integer ) ) );
        assert ( sym ); // compiler guarantee
	    string typ = token_to_string( sym->value );
        // E.g. typedef int integer;
	    t += "typedef " + typ + " " + sym->name + ";";
    }

}

void CodeGen::do_parameters( CodeBlock& h, CodeBlock& c )
{
    // TODO: Move this to ParameterSymbol

	// agents.h - parameter declaration
	h += "// model parameters";
    for ( auto parameter : Symbol::pp_parameters ) {
	    string type = token_to_string( parameter->type );
    	h += "extern " + type + " " + parameter->name + ";";
    }
	h += "";

	// agents.cpp - parameter definition
	c += "// model parameters";
    for ( auto parameter : Symbol::pp_parameters ) {
	    string type = token_to_string( parameter->type );
    	c += type + " " + parameter->name + " = 0.0;";
    }
	c += "";

	// populate meta-data for parameters
    for ( auto parameter : Symbol::pp_parameters ) {
        ParamDicRow paramDic;
        ParamDicTxtLangRow paramTxt;

        paramDic.paramId = parameter->pp_numeric_id;
        paramDic.paramName = parameter->name;  // must be valid database view name, if we want to use compatibility views
        paramDic.rank = 0; // TODO: currently hard-coded to scalar parmaeters for alpha
        paramDic.typeId = 12;           // TODO: hard-coded to double
        paramDic.isHidden = false; // TODO: not implemented
        paramDic.isGenerated = false; // TODO: not implemented
        paramDic.numCumulated = 0; //TODO: not implemented
        metaRows.paramDic.push_back(paramDic);

        // TODO language entries are hard-coded bilingual for alpha
        paramTxt.paramId = parameter->pp_numeric_id;
        paramTxt.langName = "EN";
        paramTxt.descr = parameter->name + " short name (EN)";
        paramTxt.note = parameter->name + " note (EN)";
        metaRows.paramTxt.push_back(paramTxt);

        paramTxt.langName = "FR";
        paramTxt.descr = parameter->name + " short name (FR)";
        paramTxt.note = parameter->name + " note (FR)";
        metaRows.paramTxt.push_back(paramTxt);

        // TODO: rank 0 parameters in alpha have no ParamDimsRows entries
    }
}

void CodeGen::do_ModelStartup( CodeBlock& h, CodeBlock& c )
{
    c += "// Model startup method: initialize parameters";
	c += "void ModelStartup(IModel * i_model)";
	c += "{";
	c += "using namespace mm;";
	c += "// load model parameters";
	c += "theLog->logMsg(\"Reading Parameters\");";
    for ( auto parameter : Symbol::pp_parameters ) {
        string name = parameter->name;
    	string typ = token_to_string( parameter->type );
    	//c += "try {";
	    c += "i_model->readParameter(\"" + name + "\", typeid(" + typ + "),  1, &" + name + ");";
        //c += "}";
	    //c += "catch(...)";
        //c += "{";
        //c += "// ignore";
        //c += "}";
    }
	c += "}";
	c += "";
}

void CodeGen::do_ModelShutdown( CodeBlock& h, CodeBlock& c )
{
	c += "// Model shutdown method: write output tables";
	c += "void ModelShutdown(IModel * i_model)";
	c += "{";
	c += "using namespace mm;";
	c += "// write output result tables";
	c += "theLog->logMsg(\"Writing Output Tables\");";
    for ( auto table : Symbol::pp_tables ) {
	    c += "the" + table->name + ".compute_expressions();";
    }
    for ( auto table : Symbol::pp_tables ) {
    	//c += "try {";
	    c += "i_model->writeOutputTable( \"" + table->name + "\", the" + table->name + ".n_accumulators, 1, const_cast<const double **>(the" + table->name + ".accumulators) );";
        //c += "}";
	    //c += "catch(...)";
        //c += "{";
        //c += "// ignore";
        //c += "}";
    }
    c += "}";
	c += "";
}

void CodeGen::do_agents( CodeBlock& h, CodeBlock& c )
{
    for ( auto agent : Symbol::pp_agents ) {

	    // agents.h
	    h += "// model agents";
        // e.g. class Person : public Agent<Person>
	    h += "class " + agent->name + " : public Agent<" + agent->name + ">";
        h += "{";
	    h += "public:";

        // Declarations and associated definitions of members used by auxiliary classes & templates
        // The C++ compiler needs these to successfully expand the template for Event, which needs to access
        // the agent member functions with fixed names.
        // They need to be declared before being used in Event class code.
        h += "int get_agent_id() const;";
        c += "";
        c += "int " + agent->name + "::get_agent_id() const";
        c += "{";
        c += "return agent_id.get();";
        c += "}";
        c += "";

        // the member age_agent for event management
        // TODO - add doxygen for generated code.
        h += "void age_agent( Time t );";
        c += "";
        c += "void " + agent->name + "::age_agent( Time t )";
        c += "{";
        c += "time.set( t );";
        c += "}";
        c += "";

        // iterate all agent events in agent
	    h += "// agent events";
        for ( auto ae : agent->pp_agentevents ) {
            h += ae->cxx_declaration_agent_scope();
        }
	    h += "";

	    h += "// agent data members";
        // iterate all agent data members in agent
        for ( auto data_member : agent->pp_agent_data_members ) {
            h += data_member->cxx_declaration_agent_scope();
            c += data_member->cxx_definition();
        }
	    h += "";

        // iterate all tables in agent
	    h += "// tables in agent";
        for ( auto table : agent->pp_agent_tables ) {
            // declaration of agent scope members
            h += table->cxx_declaration_agent_scope();
            // definition
            c += table->cxx_definition();
	    }
	    h += "";
	    c += "";

	    // member functions with fixed names
	    h += "// member functions with fixed names";
        h += "void initialize_agentvar_offsets(); // generated by openM++ compiler";
        h += "void initialize_event_offsets(); // generated by openM++ compiler";
        h += "void initialize_data_members(); // generated by openM++ compiler";
        h += "void initialize_agent_tables(); // generated by openM++ compiler";
        h += "void initialize_agent_events(); // generated by openM++ compiler";
        h += "void finalize_agent_tables(); // generated by openM++ compiler";
        h += "void finalize_agent_events(); // generated by openM++ compiler";
        h += "void om_Start_custom(); // defined in model code";
	    h += "void om_Finish_custom(); // defined in model code";
	    h += "void Start()";
	    h += "{";
	    h += "om_Start_begin();";
	    h += "om_Start_custom();";
	    h += "om_Start_end();";
        h += "}";
	    h += "void Finish()";
	    h += "{";
	    h += "om_Finish_custom();";
	    h += "om_Finish_end();";
	    h += "}";

	    h += "";

	    h += "}; // class " + agent->name + "";
	    h += "";

	    c += "";
        c += "// One-time initialization of agentvar offsets";
        c += "void " + agent->name + "::initialize_agentvar_offsets()";
        c += "{";
        for ( auto av : agent->pp_agentvars ) {
            // e.g. age.offset_in_agent = (char *)&(this->age) - (char *)this;
            c += av->name + ".offset_in_agent = (char *)&(this->" + av->name + ") - (char *)this;" ;
        }
        c += "}";

	    c += "";
        c += "// One-time initialization of event offsets";
        c += "void " + agent->name + "::initialize_event_offsets()";
        c += "{";
        for ( auto aet : agent->pp_agent_event_times ) {
            // e.g. om_time_MortalityEvent.offset_in_agent = (char *)&(this->om_time_MortalityEvent) - (char *)this;
            c += aet->name + ".offset_in_agent = (char *)&(this->" + aet->name + ") - (char *)this;" ;
        }
        c += "}";

	    c += "";
        c += "// Initialize all agent data members";
        c += "void " + agent->name + "::initialize_data_members()";
        c += "{";
        for ( auto adm : agent->pp_agent_data_members ) {
            c += adm->cxx_initialize_expression();
        }
        c += "}";

        c += "";
        c += "// Initialize tabulation-related data members";
        c += "void " + agent->name + "::initialize_agent_tables()";
        c += "{";
        for ( auto table : agent->pp_tables ) {
            c += table->do_increments_func() + "(true, false);";
        }
        c += "}";

	    c += "";
        c += "// Finalize tabulation-related operations";
        c += "void " + agent->name + "::finalize_agent_tables()";
        c += "{";
        for ( auto table : agent->pp_tables ) {
            c += table->do_increments_func() + "(false, true);";
        }
        c += "}";

	    c += "";
        c += "// Initialize events";
        c += "void " + agent->name + "::initialize_agent_events()";
        c += "{";
        for ( auto event_time : agent->pp_agent_event_times ) {
            c += event_time->name + ".make_dirty();";
        }
        c += "}";

	    c += "";
        c += "// Finalize events";
        c += "void " + agent->name + "::finalize_agent_events()";
        c += "{";
        for ( auto event_time : agent->pp_agent_event_times ) {
            c += event_time->name + ".make_zombie();";
        }
        c += "}";
    }

    c += doxygen("Free all zombie agents");
    c += "void BaseAgent::free_all_zombies()";
    c += "{";
    for ( auto agent : Symbol::pp_agents ) {
        // e.g. Person::free_zombies();
        c += agent->name + "::free_zombies();";
    }
    c += "}";

}

void CodeGen::do_tables( CodeBlock& h, CodeBlock& c )
{
	h += "// model output tables";
	c += "// model output tables";

	for ( auto table : Symbol::pp_tables ) {
        int n_accumulators = table->pp_accumulators.size();
        int n_expressions = table->pp_expressions.size();
        int n_cells = 1;

	    h += "";
	    h += "class " + table->name + " {";
        h += "public:";
        h += "void initialize_accumulators();";
        h += "void compute_expressions();";
        // constructor
        // E.g. DurationOfLife() { initialize_accumulators();}
        h += table->name + "() { initialize_accumulators();}";
        h += "";
        h += "// constants";
        h += "static const int n_cells = " + to_string(n_cells) + ";";
        h += "static const int n_accumulators = " + to_string(n_accumulators) + ";";
        h += "static const int n_expressions = " + to_string(n_expressions) + ";";

        h += "";
        h += "// expression storage";
        for ( int j = 0; j < n_expressions; j++ ) {
            h += "double expr" + to_string(j) + "[" + to_string(n_cells) + "];";
        }

        h += "";
        h += "// accumulator storage";
        for ( int j = 0; j < n_accumulators; j++ ) {
            h += "double acc" + to_string(j) + "[" + to_string(n_cells) + "];";
        }

        h += "";
        h += "// accumulator array of pointers";
        h += "double *accumulators[n_accumulators];";
        h += "";
        h += "// expression array of pointers";
	    h += "double *expressions[n_expressions];";

        h += "};";
	    h += "extern " + table->name + " the" + table->name + ";";

	    c += "";
        // table definition
        // E.g. DurationOfLife theDurationOfLife;
	    c += table->name + " the" + table->name + ";";

        // definition of initialize_accumulators()
        c += "void " + table->name + "::initialize_accumulators()";
        c += "{";
        for ( auto acc : table->pp_accumulators ) {
            string initial_value = "";
            switch ( acc->accumulator ) {
            case token::TK_sum:
                initial_value = "  0.0";
                break;
            case token::TK_min:
                initial_value = " DBL_MAX";
                break;
            case token::TK_max:
                initial_value = "-DBL_MAX";
                break;
            default:
                // not reached
                assert( 0 );
            }
            // e.g.  sum(value_in(alive))
            c += "// " + token_to_string(acc->accumulator) + "(" + token_to_string(acc->increment) + "(" + acc->agentvar->name + "))";
            // e.g. for ( int cell = 0; cell < n_cells; cell++ ) acc0[cell] =   0.0;
            c += "for ( int cell = 0; cell < n_cells; cell++ ) acc" + to_string(acc->index) + "[cell] = " + initial_value + ";";
            // e.g. accumulators[0] = acc0;
    	    c += "accumulators[" + to_string(acc->index) + "] = acc" + to_string(acc->index) + ";";
            c += "";
    	         
        }
        c += "}";
        c += "";

        // definition of compute_expressions()
        // E.g. void DurationOfLife::compute_expressions()
        c += "void " + table->name + "::compute_expressions()";
        c += "{";
        for ( auto table_expr : table->pp_expressions ) {
            // E.g.  // SUM_BEFORE( acc0 )
            c += "// " + table_expr->get_expression( table_expr->root, TableExpressionSymbol::expression_style::sql ) ;
            // E.g. expressions[0] = expr0;
            c += "expressions[" + to_string(table_expr->index) + "] = expr" + to_string(table_expr->index) + ";";
            // E.g. for ( int cell = 0; cell < n_cells; cell++ ) expressions[0][cell] = accumulators[0][cell] ;
            c += "for ( int cell = 0; cell < n_cells; cell++ ) "
                 "expressions[" + to_string(table_expr->index) + "][cell] = " + table_expr->get_expression( table_expr->root, TableExpressionSymbol::expression_style::cxx ) + " ;" ;
            c += "";
        }
        c += "}";
        c += "";
    }

	h += "";
	c += "";

    // TODO: Move all of this to member function of TableSymbol
	// populate meta-data for tables
    for ( auto table : Symbol::pp_tables ) {
        TableDicRow tableDic;
        TableDicTxtLangRow tableTxt;

        tableDic.tableId = table->pp_numeric_id;
        tableDic.tableName = table->name;
        tableDic.isUser = false;
        tableDic.rank = 0;
        tableDic.isSparse = true;   // do not store NULLs
        tableDic.isHidden = false;
        metaRows.tableDic.push_back(tableDic);

        // TODO language entries are hard-coded bilingual for alpha
        tableTxt.tableId = table->pp_numeric_id;
        tableTxt.langName = "EN";
        tableTxt.descr = table->name + " short name (EN)";
        tableTxt.note = table->name + " note (EN)";
        tableTxt.unitDescr = "Expressions (EN)"; // TODO
        tableTxt.unitNote = "Expressions Note (EN)"; // TODO
        metaRows.tableTxt.push_back(tableTxt);

        tableTxt.langName = "FR";
        tableTxt.descr = table->name + " short name (FR)";
        tableTxt.note = table->name + " note (FR)";
        tableTxt.unitDescr = "Expressions (FR)"; // TODO
        tableTxt.unitNote = "Expressions Note (FR)"; // TODO
        metaRows.tableTxt.push_back(tableTxt);

        // TODO: rank 0 tables in alpha have no TableDimsRow entries
        // or TableDimsTxtLangRow entries
        
        // accumulators for table
        TableAccRow tableAcc;
        tableAcc.tableId = table->pp_numeric_id;
        TableAccTxtLangRow tableAccTxt;
        tableAccTxt.tableId = table->pp_numeric_id;
        for ( auto acc : table->pp_accumulators ) {
            tableAcc.accId = acc->index;
            tableAcc.name = "acc" + to_string(acc->index);
            tableAcc.expr = acc->pretty_name();
            metaRows.tableAcc.push_back(tableAcc);

            tableAccTxt.accId = acc->index;
            tableAccTxt.langName = "EN";
            tableAccTxt.descr = acc->name + " short name (EN)";
            tableAccTxt.note = acc->name + " note (EN)";
            metaRows.tableAccTxt.push_back(tableAccTxt);

            tableAccTxt.langName = "FR";
            tableAccTxt.descr = acc->name + " short name (FR)";
            tableAccTxt.note = acc->name + " note (FR)";
            metaRows.tableAccTxt.push_back(tableAccTxt);
        }

        // expressions for table
        TableUnitRow tableUnit;
        tableUnit.tableId = table->pp_numeric_id;
        TableUnitTxtLangRow tableUnitTxt;
        tableUnitTxt.tableId = table->pp_numeric_id;
        for ( auto expr : table->pp_expressions ) {
            tableUnit.unitId = expr->index;
            tableUnit.name = "expr" + to_string(expr->index);
            tableUnit.src = expr->get_expression( expr->root, TableExpressionSymbol::expression_style::sql );
            metaRows.tableUnit.push_back(tableUnit);

            tableUnitTxt.unitId = expr->index;
            tableUnitTxt.langName = "EN";
            tableUnitTxt.descr = expr->name + " short name (EN)";
            tableUnitTxt.note = expr->name + " note (EN)";
            metaRows.tableUnitTxt.push_back(tableUnitTxt);

            tableUnitTxt.langName = "FR";
            tableUnitTxt.descr = expr->name + " short name (FR)";
            tableUnitTxt.note = expr->name + " note (FR)";
            metaRows.tableUnitTxt.push_back(tableUnitTxt);
        }
    }
}

void CodeGen::do_event_queue( CodeBlock& h, CodeBlock& c )
{
    c += doxygen( "The event queue (definition)" );
    c += "set<BaseEvent *, less_deref<BaseEvent *> > BaseEvent::event_queue;";
    c += doxygen( "The dirty event list (definition)" );
    c += "tailed_forward_list<BaseEvent *> BaseEvent::dirty_events;";
    c += doxygen( "The active agent list (definition)" );
    c += "list<BaseAgent *> BaseAgent::agents;";
    c += "";
}


void CodeGen::do_RunModel( CodeBlock& h, CodeBlock& c )
{
	// agents.cpp
	c += "// Model simulation (implemented in simulation.cpp for prototype)";
	c += "extern void RunModel(IModel * i_model);";
}


void CodeGen::do_API_entries( CodeBlock& h, CodeBlock& c )
{
	// agents.cpp
	c.smart_indenting ( false );
	c += "namespace openm";
	c += "{";
	c += "    // model API entries holder";
	c += "    struct ModelEntryHolder";
	c += "    {";
	c += "        ModelEntryHolder(";
	c += "            OM_STARTUP_HANDLER i_ModelStartupHandler,";
	c += "            OM_EVENT_LOOP_HANDLER i_RunModelHandler,";
	c += "            OM_SHUTDOWN_HANDLER i_ModelShutdownHandler";
	c += "            ) ";
	c += "        { ";
	c += "            ::ModelStartupHandler = i_ModelStartupHandler;    // link model startup function";
	c += "            ::RunModelHandler = i_RunModelHandler;            // link user portion of model event loop";
	c += "            ::ModelShutdownHandler = i_ModelShutdownHandler;  // link model shutdown function";
	c += "        }";
	c += "    };";
	c += "";
	c += "    // set entry points to the code generated by openM++ compiler";
	c += "    static ModelEntryHolder theModelEntry(::ModelStartup, ::RunModel, ::ModelShutdown);";
	c += "}";
	c += "";
	c.smart_indenting ( true );
}
/**
 * @file    CodeGen.cpp
 * Implements the code generation class.
 */
// Copyright (c) 2013-2014 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

#include <iostream>
#include <fstream>
#include <algorithm>
#include <utility>
#include <typeinfo>
#include "CodeGen.h"
#include "CodeBlock.h"
#include "ast.h"
#include "libopenm/db/modelBuilder.h"

using namespace std;
using namespace openm;

void CodeGen::do_all()
{

	do_preamble();

	do_types();
	do_parameters();
	do_tables();
	do_agents();
    do_event_queue();

    h += "void StartSimulation(int id);";
    h += "void EndSimulation();";

    do_ModelStartup();
    do_RunModel();
    do_ModelShutdown();
    do_API_entries();

    *oat0 << t0;
    *oat1 << t1;
    *oah << h;
    *oac << c;
}

void CodeGen::do_preamble()
{
    // Get the model symbol
    ModelSymbol *model_symbol = dynamic_cast<ModelSymbol *>(Symbol::find_a_symbol(typeid(ModelSymbol)));
    assert(model_symbol);
    model_symbol->time_stamp = time_stamp;
    model_symbol->populate_metadata(metaRows);

    // Get the model_type symbol
    ModelTypeSymbol *model_type_symbol = dynamic_cast<ModelTypeSymbol *>(Symbol::find_a_symbol(typeid(ModelTypeSymbol)));
    assert(model_type_symbol);
    model_type_symbol->populate_metadata(metaRows);

    // Get the version symbol
    VersionSymbol *version_symbol = dynamic_cast<VersionSymbol *>(Symbol::find_a_symbol(typeid(VersionSymbol)));
    assert(version_symbol);
    version_symbol->populate_metadata(metaRows);

    // om_types0.h
    t0 += doxygen(
        "@file   om_types0.h",
        "Fundamental Types for model '" + model_symbol->name + "' - Generated by openM++ compiler",
        " ",
        " Model version = " + version_symbol->formatted_value(),
        " Time stamp = " + model_symbol->time_stamp
        );
    t0 += "";
    t0 += "#pragma once";
    t0 += "#include <cmath>";
    t0 += "";

    // om_types1.h
    t1 += doxygen(
                "@file   om_types1.h",
                "Types for model '" + model_symbol->name + "' - Generated by openM++ compiler",
                " ",
                " Model version = " + version_symbol->formatted_value(),
                " Time stamp = " + model_symbol->time_stamp
                );
    t1 += "" ;
	t1 += "#pragma once";
    t1 += "#include \"om_types0.h\"";
    t1 += "#include \"omc/Range.h\"";
    t1 += "#include \"omc/Partition.h\"";
    t1 += "#include \"omc/Classification.h\"";
    t1 += "";

    // om_declarations.h
    h += doxygen(
                "@file   om_declarations.h",
                "Declarations for model '" + model_symbol->name + "' - Generated by openM++ compiler",
                " ",
                " Model version = " + version_symbol->formatted_value(),
                " Time stamp = " + model_symbol->time_stamp
                );
    h += "" ;
	h += "#pragma once";
	h += "#include \"omc/omSimulation.h\"";
    h += "";
    h += "using namespace std;";
    h += "";

    // om_definitions.cpp
    c += doxygen(
                "@file   om_definitions.cpp",
                "Definitions for model '" + model_symbol->name + "' - Generated by openM++ compiler",
                " ",
                " Model version = " + version_symbol->formatted_value(),
                " Time stamp = " + model_symbol->time_stamp
                );
	c += "";
    c += "#include <cassert>";
    c += "#include <typeinfo>";
    c += "#include \"omc/omSimulation.h\"";
    c += "";

    // Get definition code associated with the model_type symbol (#include of framework code)
    c += model_type_symbol->cxx_definition_global();
    c += "";

    // Get definition code associated with the model symbol (name, time stamp)
    c += model_symbol->cxx_definition_global();
    c += "";

	c += "using namespace openm;";
	c += "";
}

void CodeGen::do_types()
{
    // om_types0.h - fundamental types declaration
    t0 += "// fundamental types";
    for (auto type : Symbol::pp_all_types0) {
        t0 += type->cxx_declaration_global();
    }
    t0 += "";

    // om_types1.h - templated types declaration
    t1 += "// templated types";
    for (auto type : Symbol::pp_all_types1) {
        t1 += type->cxx_declaration_global();
    }
    t1 += "";

    // om_definitions.cpp - types definitions
    c += "// fundamental types";
    for (auto type : Symbol::pp_all_types0) {
        c += type->cxx_definition_global();
    }
    c += "";

    c += "// templated types";
    for (auto type : Symbol::pp_all_types1) {
        c += type->cxx_definition_global();
    }
    c += "";

    // populate meta-data for types
    for (auto type : Symbol::pp_all_types0) {
        type->populate_metadata(metaRows);
    }
    for (auto type : Symbol::pp_all_types1) {
        type->populate_metadata(metaRows);
    }
}

void CodeGen::do_parameters()
{
	// agents.h - parameter declaration
	h += "// model parameters";
    for ( auto parameter : Symbol::pp_all_parameters ) {
        h += parameter->cxx_declaration_global();
    }
	h += "";

	// agents.cpp - parameter definition
	c += "// model parameters";
    for ( auto parameter : Symbol::pp_all_parameters ) {
        c += parameter->cxx_definition_global();
    }
	c += "";

	// populate meta-data for parameters
    for ( auto parameter : Symbol::pp_all_parameters ) {
        parameter->populate_metadata(metaRows);
    }
}

void CodeGen::do_ModelStartup()
{
    c += "// Model startup method: initialization, inputs";
	c += "void ModelStartup(IModel * i_model)";
	c += "{";

    c += "// Agent static initialization pass #1: Initialize agent member offsets & null agent data members";
    for (auto agent : Symbol::pp_all_agents) {
        c += "// Agent - " + agent->name;
        c += agent->name + "::om_null_agent.om_initialize_agentvar_offsets();";
        c += agent->name + "::om_null_agent.om_initialize_event_offsets();";
        c += agent->name + "::om_null_agent.om_initialize_data_members0();";
        c += "";
    }

    c += "// Agent static initialization pass #2: Initialize null agent dependent agentvars";
    for (auto agent : Symbol::pp_all_agents) {
        c += "// Agent - " + agent->name;
        c += agent->name + "::om_null_agent.om_initialize_expression_agentvars();";
    }
    c += "";

    c += "// Sanity type check of storage type and readParameters type argument";
    for (auto parameter : Symbol::pp_all_parameters) {
        c += parameter->cxx_assert_sanity();
    }
    c += "";

    c += "theLog->logMsg(\"Reading Parameters\");";
    for (auto parameter : Symbol::pp_all_parameters) {
        c += "i_model->" + parameter->cxx_read_parameter();
    }

	c += "}";
	c += "";
}

void CodeGen::do_ModelShutdown()
{
	c += "// Model shutdown method: outputs";
	c += "void ModelShutdown(IModel * i_model)";
	c += "{";
	c += "// write output result tables";
	c += "theLog->logMsg(\"Writing Output Tables\");";
    for ( auto table : Symbol::pp_all_tables ) {
	    c += "the" + table->name + ".compute_expressions();";
    }
    for ( auto table : Symbol::pp_all_tables ) {
	    c += "i_model->writeOutputTable( \"" + table->name + "\", the" + table->name + ".n_accumulators, " + to_string(table->cell_count()) + ", const_cast<const double **>(the" + table->name + ".accumulators) );";
    }
    c += "}";
	c += "";
}

void CodeGen::do_agents()
{
	h += "// forward declarations of model agent classes (for links)";
    for (auto agent : Symbol::pp_all_agents) {
        h += "class " + agent->name + ";";
    }
    h += "";
    for ( auto agent : Symbol::pp_all_agents ) {

	    h += "// model agent classes";
        // e.g. class Person : public Agent<Person>
	    h += "class " + agent->name + " : public Agent<" + agent->name + ">";
        h += "{";
	    h += "public:";

	    h += "";
	    h += "//";
	    h += "// function members in " + agent->name + " agent";
	    h += "//";
	    h += "";
        for ( auto func_member : agent->pp_agent_funcs ) {
            h += func_member->cxx_declaration_agent();
            c += func_member->cxx_definition_agent();
        }

	    h += "";
	    h += "//";
	    h += "// data members in " + agent->name + " agent";
	    h += "//";
	    h += "";
        for ( auto data_member : agent->pp_agent_data_members ) {
            h += data_member->cxx_declaration_agent();
            c += data_member->cxx_definition_agent();
        }

        h += "// The declaration of the single static " + agent->name;
        h += "// used to retrieve (zero) values when dereferencing nullptr link agentvars.";
        h += "static " + agent->name + " " + "om_null_agent;";

	    h += "}; // class " + agent->name;
	    h += "";

        c += "// The definition of the single static " + agent->name;
        c += "// used to retrieve (zero) values when dereferencing nullptr link agentvars.";
        c += agent->name + " " + agent->name + "::om_null_agent;";
    }

    c += "// definition of global time (declaration in Agent.h)";
    c += "Time BaseAgent::global_time;";
    c += "";

    c += doxygen("Free all zombie agents");
    c += "void BaseAgent::free_all_zombies()";
    c += "{";
    for ( auto agent : Symbol::pp_all_agents ) {
        // e.g. Person::free_zombies();
        c += agent->name + "::free_zombies();";
    }
    c += "}";

}

void CodeGen::do_tables()
{
	h += "// model output tables";
	c += "// model output tables";

	for ( auto table : Symbol::pp_all_tables ) {
        h += table->cxx_declaration_global();
        c += table->cxx_definition_global();
        table->populate_metadata(metaRows);
    }

	h += "";
	c += "";
}

void CodeGen::do_event_queue()
{
    c += doxygen( "The event queue (definition)" );
    c += "set<BaseEvent *, less_deref<BaseEvent *> > BaseEvent::event_queue;";
    c += doxygen( "The dirty event list (definition)" );
    c += "tailed_forward_list<BaseEvent *> BaseEvent::dirty_events;";
    c += doxygen( "The active agent list (definition)" );
    c += "list<BaseAgent *> BaseAgent::agents;";
    c += "";
}


void CodeGen::do_RunModel()
{
	// agents.cpp
	c += "// Model simulation (implemented in omSimulation_casebased.cpp or omSimulation_timebased.cpp)";
	c += "extern void RunModel(IModel * i_model);";
    c += "";
}


void CodeGen::do_API_entries()
{
	// agents.cpp
	c.smart_indenting ( false );
	c += "namespace openm";
	c += "{";
	c += "    // set entry points to the code generated by openM++ compiler";
	c += "    static ModelEntryHolder theModelEntry(::ModelStartup, ::RunModel, ::ModelShutdown);";
	c += "}";
	c += "";
	c.smart_indenting ( true );
}
# Copyright (c) 2013 OpenM++
# This code is licensed under MIT license (see LICENSE.txt for details)

# Create openM++ database for a subsequent run of a model
# Run this script from the /openm/test_models folder
# Argument is the name of a model, located in a sister directory of test_models, e.g. Alpha1

# Input files:
#   Alpha1_inputs.pl - input parameter values for Alpha1
# 
# Creates a new openM++ database, which  has a fixed model_id of 11.


my $version = 1.0;

if ( $#ARGV+1 != 1 ) {
	print "inputs version $version\n";
	print "usage: inputs modelname\n";
	exit -1;
}

# name of model (from first argument)
my $model_name = $ARGV[0];

# for diagnostics
my $debug = 1;

# sqlite3 executable (assumed to be accessible from Path)
my $sqlite_exe = "sqlite3.exe";

# sql source to create fresh database
my $create_db_sql = "../sql/sqlite/create_db_sqlite.sql";

# model database
my $model_db = $model_name . ".sqlite";

# sql source to insert model metadata
my $create_model_sql =  "../build/${model_name}/src/" . $model_name . "_create_model.sql";

# sql source to insert model parameters (generated by this script)
my $insert_param_sql = "../build/${model_name}/src/" . $model_name . "_insert_param.sql";

# erase model database
unlink ${model_db};

if ( $debug ) {
	print "Create starting sqlite database - start", "\n";
}
open(SQLITE, "|${sqlite_exe} ${model_db}") || "Failed to open pipe: |${sqlite_exe} ${model_db}\n";
open(CREATE_DB, "<${create_db_sql}") || die "Failed to open ${create_db_sql}\n";
while (<CREATE_DB>) {
	print SQLITE;
}
close(CREATE_DB);
close(SQLITE); # close pipe to sqlite executable so that error message line indicators correspond to the sql source file
if ( $debug ) {
	print "Create starting sqlite database - end", "\n\n";
}

# insert model metadata, and grab stuff. model_id will be 11
my $model_time_stamp;
my @parameters;
my @tables;
my @parameter_value_tables;
my @table_value_tables;

if ( $debug ) {
	print "Insert model metadata in sqlite database - start", "\n";
}
open(SQLITE, "|${sqlite_exe} ${model_db}") || "Failed to open pipe: |${sqlite_exe} ${model_db}\n";
open(CREATE_MODEL, "<${create_model_sql}") || die "Fail to open ${create_model_sql}\n";
while (<CREATE_MODEL>) {
	if ( m/model timestamp:[^_]*_([0-9]+)_/ ) {
		# note model time stamp
		$model_time_stamp = $1;
	}
	if ( m/^INSERT INTO parameter_dic .*, ['](\w+)/ ) {
		# extracts the word inside  the first '' delimited string
		push @parameters, $1;
	}
	if ( m/^INSERT INTO table_dic .*, ['](\w+)/ ) {
		# extracts the word inside  the first '' delimited string
		push @tables, $1;
	}
	if ( m/^CREATE TABLE (\w+)/ ) {
		my $sql_table = $1;
		if ( $sql_table =~ /_w[0-9]+_/ ) {
			push @parameter_value_tables, $sql_table;
		}
		elsif ( $sql_table =~ /_s[0-9]+_/ ) {
			push @table_value_tables, $sql_table;
		}
	}

	print SQLITE;
}
close(CREATE_MODEL);
close(SQLITE); # close pipe to sqlite executable so that error message line indicators correspond to the sql source file

if ( $debug ) {
	print "Insert model metadata in sqlite database - end", "\n\n";
}

if ( $debug ) {
	print "\nPARAMETERS:\n";
	foreach my $parameter (@parameters) { print "$parameter\n"; }
	print "\nPARAMETER VALUE TABLES:\n";
	foreach my $parameter_value_table (@parameter_value_tables) { print "$parameter_value_table\n"; }
	print "\nTABLES:\n";
	foreach my $table (@tables) { print "$table\n"; }
	print "\nTABLE VALUE TABLES:\n";
	foreach my $table_value_table (@table_value_tables) { print "$table_value_table\n"; }
}

if ( $debug ) {
	print "\nModel time stamp = $model_time_stamp\n";
}

# create run time stamp based on current time
my $run_time_stamp;
my $run_time_stamp_readable;
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
$year += 1900;
$mon++;
$run_time_stamp_readable = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year, $mon, $mday, $hour, $min, $sec);
$run_time_stamp = sprintf("%04d%02d%02d%02d%02d%02d%04d", $year, $mon, $mday, $hour, $min, $sec, 0);;
if ( $debug ) {
	print "\nRun time stamp   = $run_time_stamp '${run_time_stamp_readable}'\n";
}

# parameter values from included perl script (in hash %parameter_values)
# are placed into the global %parameter_values
do "${model_name}_inputs.pl" || die "error with parameter file" ;

if ( $debug ) {
	print "\nPARAMETER VALUES:\n";
}

while (my ($parameter, $value) = each %parameter_values) {
	print "${parameter}=${value}", "\n";
}

# Create insert_param.sql script
my $set_id = 5;
my $model_id = 11;
my $run_name = lc("${model_name}_${run_time_stamp}_run_${set_id}");

open(INSERT_PARAM_SQL, ">$insert_param_sql")  || die("CreateJobs: Failed to create $insert_param_sql");

print INSERT_PARAM_SQL "-- insert parameters for model: ${model_name}", "\n";
print INSERT_PARAM_SQL "-- model timestamp: _${run_time_stamp}_", "\n";
print INSERT_PARAM_SQL "-- script created at: ${run_time_stamp_readable}", "\n";
print INSERT_PARAM_SQL "--", "\n";

print INSERT_PARAM_SQL "\nINSERT INTO workset_lst", "\n";
print INSERT_PARAM_SQL "  (set_id, run_id, model_id, is_readonly, update_dt)", "\n";
print INSERT_PARAM_SQL "VALUES", "\n";
print INSERT_PARAM_SQL "  (${set_id}, NULL, ${model_id}, 1, '${run_time_stamp_readable}');", "\n";
print INSERT_PARAM_SQL "\nINSERT INTO workset_txt (set_id, model_id, lang_id, descr, note)", "\n";
print INSERT_PARAM_SQL "VALUES", "\n";
print INSERT_PARAM_SQL "  (${set_id}, ${model_id}, 0, '${model_name} default parameters', '${model_name} default set of input parameters');", "\n";
							   
for (my $j=0; $j<=$#parameters; $j++) {
	my $parameter_id = $j;
	my $parameter_name = @parameters[$j];

	print INSERT_PARAM_SQL "\n";
	print INSERT_PARAM_SQL "INSERT INTO workset_parameter (set_id, model_id, parameter_id)", "\n";
	print INSERT_PARAM_SQL "VALUES", "\n";
	print INSERT_PARAM_SQL "  (${set_id}, ${model_id}, ${parameter_id});", "\n";

	print INSERT_PARAM_SQL "\n";
	print INSERT_PARAM_SQL "INSERT INTO workset_parameter_txt (set_id, model_id, parameter_id, lang_id, note)", "\n";
	print INSERT_PARAM_SQL "VALUES", "\n";
	print INSERT_PARAM_SQL "  (${set_id}, ${model_id}, ${parameter_id}, 0, 'Value note for ${parameter_name}');", "\n";

	my $parameter_value_table = @parameter_value_tables[$j];
	my $parameter_value = 0.5; #arbitrary default value
	if ( exists $parameter_values{$parameter_name} ) {
		$parameter_value = $parameter_values{$parameter_name};
	}
	print INSERT_PARAM_SQL "INSERT INTO ${parameter_value_table} (set_id, Value) VALUES (${set_id}, ${parameter_value});", "\n";
}

close(INSERT_PARAM_SQL);

if ( $debug ) {
	print "Insert parameter values to sqlite database - start", "\n";
}
open(INSERT_PARAM, "<${insert_param_sql}") || die "Failed to open ${insert_param_sql}\n";
open(SQLITE, "|${sqlite_exe} ${model_db}") || "Failed to open pipe: |${sqlite_exe} ${model_db}\n";
while (<INSERT_PARAM>) {
	print SQLITE;
}
close(INSERT_PARAM);
close(SQLITE); # close pipe to sqlite executable so that error message line indicators correspond to the sql source file
if ( $debug ) {
	print "Insert parameter values to sqlite database - end", "\n\n";
}


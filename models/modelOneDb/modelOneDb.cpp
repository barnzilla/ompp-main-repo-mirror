/**
* @file
* OpenM++ db library usage example
* 
* This is an example how to use IDbExec data access interface of OpenM++ runtime library.
* It is also include usage of common helper functions and utility classes, like openm::ILog.
*
* You need openM++ modelOne database in order to run this example.
*/
// Copyright (c) OpenM++
// This code is licensed under the MIT license (see LICENSE.txt for details)

#include "modelOneDb.h"
using namespace openm;

/** model name for openM++ models:
* - normally it is set by model compiler (omc) 
* - usually same as model directory name and VC project name
* - name and digest is used find model data in database
* - by default database file name: ModelName.sqlite
*
* All above is not a requirement, but just a convention,
* and in this project we are using "modelOne" name in order to access "modelOne" model in db
*/
static const char * OM_MODEL_NAME = "modelOne";

/** model metadata digest: unique model key 
* normally it is set by model compiler (omc) 
* model metadata digest expected to be 32 digits hex
* modelOne is using special test value instead of actual digest
*/
static const char * OM_MODEL_DIGEST = "_201208171604590148_";

// copy from metaLoader.cpp: command line or ini-file options keys
//
// const char * RunOptionsKey::dbConnStr = "OpenM.Database";
static const char * dbConnStrArgKey = "OpenM.Database";

// const char * RunOptionsKey::useSparse = "OpenM.SparseOutput";
static const char * useSparseKey = "OpenM.SparseOutput";

// const char * RunOptionsKey::sparseNull = "OpenM.SparseNullValue";
static const char * sparseNullKey = "OpenM.SparseNullValue";

// convert to string format for float, double, long double 
//const char * RunOptionsKey::doubleFormat = "OpenM.DoubleFormat";
static const char * doubleFormatKey = "OpenM.DoubleFormat";

// copy from metaLoader.cpp:
/** array of model run option keys to use on command line or insise of ini-file */
static const char * runOptKeyArr[] = {
    dbConnStrArgKey,        // RunOptionsKey::dbConnStr,
    useSparseKey,           // const char * RunOptionsKey::useSparse,
    sparseNullKey,          // const char * RunOptionsKey::sparseNull,
    doubleFormatKey,        // const char * RunOptionsKey::doubleFormat,
    ArgKey::optionsFile,
    ArgKey::logToConsole,
    ArgKey::logToFile,
    ArgKey::logFilePath,
    ArgKey::logToStamped,
    ArgKey::logUseTs,
    ArgKey::logUsePid,
    ArgKey::logNoMsgTime,
    ArgKey::logSql
};
static const size_t runOptKeySize = sizeof(runOptKeyArr) / sizeof(const char *);

// copy from modelRunState.cpp
/** s = completed successfully */
const char * RunStatus::done = "s";

/** p = run in progress */
const char * RunStatus::progress = "p";

/** demo exception default error message */
const char openm::demoUnknownErrorMessage[] = "demo model unknown error";

// copy from modelOne code:
//
// "modelOne" model dimensions, parameters and output table(s)
// usually definitions below generated by omc model compiler
//

// "modelOne" type "full": full or part time job
enum jobKind : int
{
    fullTime = 22,
    partTime = 33
};

// "modelOne" dimensions size
const size_t N_AGE = 4;
const size_t N_SEX = 2;
const size_t N_SALARY = 3;

// "modelOne" model parameters
static int startSeed = 1;
static double ageSex[N_AGE][N_SEX];
static int salaryAge[N_SALARY][N_AGE];
static int salaryFull[N_SALARY];
static int baseSalary = jobKind::partTime;
static string filePath;

// "modelOne" output table: salary by sex
// normally each subsample has it own thread local storage for each output table
// because our demo is using model run with one subsample only and no modeling threads
// then output table storage defined as:
//
static const size_t N_CELL = N_SALARY * (N_SEX + 1);    // number of cells, "sex" dimension has total enabled
static const size_t N_ACC = 2;                          // number of accumulators
static const size_t ACC_SUM_ID = 0;                     // accumulator 0: sum
static const size_t ACC_COUNT_ID = 1;                   // accumulator 1: count

// modelOne.cpp: 
// thread_local unique_ptr<SalarySex> theSalarySex; // salary by sex
double salarySexAcc[N_ACC][N_CELL];

/** main entry point */
int main(int argc, char ** argv) 
{
    try {
        // get model run options from command line and ini-file
        const ArgReader argOpts(argc, argv, runOptKeySize, runOptKeyArr);

        // adjust log file(s) with actual log settings specified in model run options file
        theLog->init(
            argOpts.boolOption(ArgKey::logToConsole) || !argOpts.isOptionExist(ArgKey::logToConsole),
            argOpts.strOption(ArgKey::logFilePath).c_str(),
            argOpts.boolOption(ArgKey::logUseTs),
            argOpts.boolOption(ArgKey::logUsePid),
            argOpts.boolOption(ArgKey::logNoMsgTime),
            argOpts.boolOption(ArgKey::logSql)
        );
        theLog->logMsg("Model", OM_MODEL_NAME);

        // get db-connection string or use default if not specified
        string connectionStr = argOpts.strOption(
            dbConnStrArgKey,    // RunOptionsKey::dbConnStr,
            string("Database=") + OM_MODEL_NAME + ".sqlite; Timeout=86400; OpenMode=ReadWrite;"
        );

        // open db-connection
        unique_ptr<IDbExec> dbExec(IDbExec::create(SQLITE_DB_PROVIDER, connectionStr));

        // load model metadata (part of metadata required to run the model)
        unique_ptr<MetaHolder> metaStore(readMetaTables(dbExec.get()));

        // select first model run where number of subsamples == 1 and completed successfuly
        RunLstRow firstRunRow = selectFirstRun(dbExec.get(), metaStore.get());
        theLog->logFormatted("Model run: %d, %s", firstRunRow.runId, firstRunRow.createDateTime.c_str());

        // read all model parameters for the model run
        readAllParameters(dbExec.get(), metaStore.get(), firstRunRow.runId);

        // do the simulation: calculate model output model accumulators
        doSimulation();

        // read all model parameters for the model run
        writeAllOutputTables(dbExec.get(), metaStore.get(), argOpts, firstRunRow.runId);
    }
    catch(HelperException & ex) {
        theLog->logErr(ex, "Helper error");
        return EXIT_FAILURE;
    }
    catch(DbException & ex) {
        theLog->logErr(ex, "DB error");
        return EXIT_FAILURE;
    }
    catch(exception & ex) {
        theLog->logErr(ex);
        return EXIT_FAILURE;
    }
    catch(...) {    // exit with failure on unhandled exception
        theLog->logMsg("FAILED");
        return EXIT_FAILURE;
    }

    theLog->logMsg("Done.");
    return EXIT_SUCCESS;
}

// read model metadata from db, part of metadata which required to run the model
// code below is a cosmetic modification of readMetaTables() from metaLoder.cpp
MetaHolder * readMetaTables(IDbExec * i_dbExec)
{
    // find model by name digest
    unique_ptr<MetaHolder> metaStore(new MetaHolder);
    metaStore->modelTable.reset(IModelDicTable::create(i_dbExec, OM_MODEL_NAME, OM_MODEL_DIGEST));

    metaStore->modelRow = metaStore->modelTable->byNameDigest(OM_MODEL_NAME, OM_MODEL_DIGEST);
    if (metaStore->modelRow == nullptr) throw DbException("model %s not found in the database", OM_MODEL_NAME);

    int mId = metaStore->modelRow->modelId;

    // read metadata tables
    metaStore->typeDic.reset(ITypeDicTable::create(i_dbExec, mId));
    metaStore->typeEnumLst.reset(ITypeEnumLstTable::create(i_dbExec, mId));
    metaStore->paramDic.reset(IParamDicTable::create(i_dbExec, mId));
    metaStore->paramDims.reset(IParamDimsTable::create(i_dbExec, mId));
    metaStore->tableDic.reset(ITableDicTable::create(i_dbExec, mId));
    metaStore->tableDims.reset(ITableDimsTable::create(i_dbExec, mId));
    metaStore->tableAcc.reset(ITableAccTable::create(i_dbExec, mId));
    metaStore->tableExpr.reset(ITableExprTable::create(i_dbExec, mId));

    return metaStore.release();
}

// select first model run where number of subsamples == 1 and completed successfuly
RunLstRow selectFirstRun(IDbExec * i_dbExec, const MetaHolder * i_metaStore)
{
    vector<RunLstRow> runLst = IRunLstTable::select(i_dbExec, i_metaStore->modelRow->modelId);
    auto it = std::find_if(
        runLst.cbegin(), 
        runLst.cend(),
        [](const RunLstRow & i_row) -> bool { return i_row.subCount == 1 && i_row.status == RunStatus::done; }
    );
    if (it == runLst.cend()) 
        throw DemoException("no model runs found, expected at least one, model: %s", i_metaStore->modelRow->name.c_str());

    return *it;
}

// read all model parameters, sub-value index =0
// OpenM++ parameters can have "sub-values" (such feature does not exist in Modgen)
// there is always sub-value with index =0 for any model parameter
void readAllParameters(IDbExec * i_dbExec, const MetaHolder * i_metaStore, int i_runId)
{
    // load model parameters
    theLog->logMsg("Reading Parameters, sub-value 0");
    readModelParameter(i_dbExec, i_metaStore, i_runId, "StartingSeed", 0, typeid(int), 1, &startSeed);
    readModelParameter(i_dbExec, i_metaStore, i_runId, "ageSex", 0, typeid(double), N_AGE * N_SEX, ageSex);
    readModelParameter(i_dbExec, i_metaStore, i_runId, "salaryAge", 0, typeid(int), N_SALARY * N_AGE, salaryAge);
    readModelParameter(i_dbExec, i_metaStore, i_runId, "salaryFull", 0, typeid(int), N_SALARY, salaryFull);
    readModelParameter(i_dbExec, i_metaStore, i_runId, "baseSalary", 0, typeid(int), 1, &baseSalary);
    readModelParameter(i_dbExec, i_metaStore, i_runId, "filePath", 0, typeid(string), 1, &filePath);
}

// code below is a cosmetic modification of:
// void SingleController::readParameter(
//    const char * i_name, const type_info & i_type, size_t i_size, void * io_valueArr
// )
/**
* read input parameter values used for specific model run.
*
* @param[in]     i_dbExec    database connection
* @param[in]     i_metaStore model metadata
* @param[in]     i_runId     model run id
* @param[in]     i_name      parameter name
* @param[in]     i_subId     parameter sub-value index
* @param[in]     i_type      parameter type
* @param[in]     i_size      parameter size (number of parameter values)
* @param[in,out] io_valueArr array to return parameter values, size must be =i_size
*/
void readModelParameter(
    IDbExec * i_dbExec, 
    const MetaHolder * i_metaStore, 
    int i_runId, 
    const char * i_name, 
    int i_subId,
    const type_info & i_type, 
    size_t i_size, 
    void * io_valueArr
)
{
    if (i_name == nullptr || i_name[0] == '\0') throw DbException("invalid (empty) input parameter name");

    try {
        // read parameter from db
        unique_ptr<IParameterReader> reader(
            IParameterReader::create(i_runId, i_name, i_dbExec, i_metaStore)
            );
        reader->readParameter(i_dbExec, i_subId, i_type, i_size, io_valueArr);
    }
    catch (exception & ex) {
        throw DbException("Failed to read input parameter: %s. %s", i_name, ex.what());
    }
}

// cosmetic modification of modelOne.cpp:
// void RunModel(IModel * const i_model)
//
// do the simulation
void doSimulation(void)
{
    // calculate model output model accumulators: just some test value
    theLog->logMsg("Running Simulation");

    for (size_t nAcc = 0; nAcc < N_ACC; nAcc++) {
        size_t nCell = 0;
        for (size_t nSalary = 0; nSalary < N_SALARY; nSalary++) {
            for (size_t nSex = 0; nSex < N_SEX; nSex++) {
                salarySexAcc[nAcc][nCell++] = (double)(nSalary + nSex + startSeed);
            }
            // "sex" dimension has total enabled: make test value for "total"
            salarySexAcc[nAcc][nCell++] = (double)(nSalary + 800);
        }
    }
}

// cosmetic modification of modelOne.cpp:
// void ModelShutdown(IModel * const i_model)
// void RunController::doShutdownRun(....)
//
// write all model output tables
void writeAllOutputTables(IDbExec * i_dbExec, const MetaHolder * i_metaStore, const ArgReader & i_argOpts, int i_runId)
{
    // write output result tables: salarySex sub-sample
    theLog->logMsg("Writing Output Tables");

    // code below is simplified copy from: void RunController::doShutdownRun(....)
    //
    // for each ouput table: 
    // update modeling progress in database
    int mId = i_metaStore->modelRow->modelId;
    {
        // do all in thransaction scope
        unique_lock<recursive_mutex> lck = i_dbExec->beginTransactionThreaded();

        for (IRowBaseVec::difference_type nTbl = 0; nTbl < i_metaStore->tableDic->rowCount(); nTbl++) {

            // skip other models (should never happen because we have metadata only for one model)
            const TableDicRow * tblRow = i_metaStore->tableDic->byIndex(nTbl);
            if (tblRow->modelId != mId) continue;

            // update model progress 
            // and clear run digest (demo only: normally run digest is cleared at run initialization)
            i_dbExec->update(
                "UPDATE run_lst SET status = " + toQuoted(RunStatus::progress) + ", " +
                " update_dt = " + toQuoted(makeDateTime(chrono::system_clock::now())) + ", " +
                " run_digest = ''" +
                " WHERE run_id = " + to_string(i_runId)
            );

            // demo only: delete existing data from output tables
            // demo only: model never does anything like this, you should NOT do it in real model
            //
            i_dbExec->update(
                "DELETE FROM run_table WHERE run_id = " + to_string(i_runId) + " AND table_hid = " + to_string(tblRow->tableHid)
            );
            i_dbExec->update("DELETE FROM " + tblRow->dbExprTable + " WHERE run_id = " + to_string(i_runId));
            i_dbExec->update("DELETE FROM " + tblRow->dbAccTable + " WHERE run_id = " + to_string(i_runId));
        }
     
        i_dbExec->commit(); // done with delete: no model run results in database (delete is a demo only code)
    }
    
    // cosmetic modification of modelOne.cpp:
    // void ModelShutdown(IModel * const i_model)
    //
    // for all output tables:
    // write output table accumulators table and calculate output table expresiisons
    // in our demo we have onlty one output table "salarySex"
    writeDemoOutputTable(i_dbExec, i_metaStore, i_runId, i_argOpts, "salarySex", N_ACC, N_CELL, (double *)salarySexAcc);

    // code below is simplified copy from: void RunController::doShutdownRun(....)
    //
    // calculate and update run digest 
    // update model run status as successfuly completed
    {
        // do all in thransaction scope
        unique_lock<recursive_mutex> lck = i_dbExec->beginTransactionThreaded();

        string sDigest = IRunLstTable::digestRun(i_dbExec, mId, i_runId);

        i_dbExec->update(
            "UPDATE run_lst SET status = " + toQuoted(RunStatus::done) + ", " +
            " update_dt = " + toQuoted(makeDateTime(chrono::system_clock::now())) + ", " +
            " run_digest = " + ((!sDigest.empty()) ? toQuoted(sDigest) : "NULL") +
            " WHERE run_id = " + to_string(i_runId)
        );
        i_dbExec->commit();     // done with model run
    }
}

// simplified version of:
// void ModelBase::writeOutputTable(....)
// void RunController::doWriteAccumulators(....)
// void RunController::writeOutputValues(....) const
// void RunController::doShutdownRun(....)
//
// simplifications are:
// - only one subsample is used, no modeling threads, no thread local storage
// - no "restart subsample", no model status update, no any kind of model life cycle
//
// also because it is a demo of database api and not a real modeling
// we are deleting existing results of model run and re-inserting it again
// real model never does any delete that
//
// write model output table
void writeDemoOutputTable(
    IDbExec * i_dbExec,
    const MetaHolder * i_metaStore,
    int i_runId,
    const ArgReader & i_argOpts,
    const char * i_name,
    size_t i_accCount,
    size_t i_accSize,
    const double * i_accValues
)
{
    // find model output table metadata
    int mId = i_metaStore->modelRow->modelId;

    const TableDicRow * tblRow = i_metaStore->tableDic->byModelIdName(mId, i_name);
    if (tblRow == nullptr) throw new DbException("output table not found in table dictionary: %s", i_name);

    vector<TableAccRow> accVec = i_metaStore->tableAcc->byModelIdTableId(mId, tblRow->tableId);
    if (accVec.size() != i_accCount) throw new DbException("output table accumulators not found: %s", i_name);

    // simplified version of: void RunController::doWriteAccumulators(....)
    //
    // write accumulators into database
    unique_ptr<IOutputTableWriter> accWriter(IOutputTableWriter::create(
        i_runId,
        i_name,
        i_dbExec,
        i_metaStore,
        1,              // subSampleCount, we are using one subsample in our demo
        i_argOpts.boolOption(useSparseKey),
        i_argOpts.doubleOption(sparseNullKey, FLT_MIN)
    ));

    for (size_t k = 0; k < i_accCount; k++) {
        accWriter->writeAccumulator(
            i_dbExec,
            0,              // subSampleNumber, we are using one subsample in our demo
            accVec[k].accId,
            i_accSize,
            i_accValues
        );
    }

    // simplified version of: void RunController::writeOutputValues(....)
    //
    // write output tables aggregated values into database 
    unique_ptr<IOutputTableWriter> valueWriter(IOutputTableWriter::create(
        i_runId,
        tblRow->tableName.c_str(),
        i_dbExec,
        i_metaStore,
        1,              // subSampleCount, we are using one subsample in our demo
        i_argOpts.strOption(doubleFormatKey).c_str()
    ));
    valueWriter->writeAllExpressions(i_dbExec);
    valueWriter->digestOutput(i_dbExec);
}

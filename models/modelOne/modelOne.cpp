// ModelOne: generated by openM++ compiler
// Copyright (c) 2013-2014 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

#include "modelOne_om.h"
using namespace openm;

// model type "full": full or part time job
enum jobKind : int
{
    fullTime = 22,
    partTime = 33
};

// model parameters
static int startSeed = 1;
static double ageSex[ageSize][sexSize];
static int salaryAge[salarySize][ageSize];
static int salaryFull[salarySize];
static int baseSalary = jobKind::partTime;

// model output tables: salary by sex
const char * SalarySex::NAME = "salarySex";
thread_local unique_ptr<SalarySex> theSalarySex; // salary by sex

// Model event loop: user code
void RunModel(IModel * const i_model)
{
    theLog->logMsg("Running Simulation");

    // calculte salary by sex, accumulator 0: sum
    // "sex" dimension has total enabled
    size_t nCell = 0;

    for (size_t nSalary = 0; nSalary < salarySize; nSalary++) {
        for (size_t nSex = 0; nSex < sexSize; nSex++) {
            for (size_t nAge = 0; nAge < ageSize; nAge++) {

                // make some test value
                theSalarySex->acc[SalarySex::ACC_Sum][nCell] +=
                    ((double)salaryAge[nSalary][nAge]) * ageSex[nAge][nSex] * (double)(i_model->subSampleNumber() + 1);
            }
            nCell++;
        }
        theSalarySex->acc[SalarySex::ACC_Sum][nCell++] =
            ((double)(nSalary + 800 * i_model->subSampleNumber() + 1));
    }

    // calculte salary by sex, accumulator 1: count
    // "sex" dimension has total enabled
    nCell = 0;

    for (size_t nSalary = 0; nSalary < salarySize; nSalary++) {

        int nFullBonus = (salaryFull[nSalary] == jobKind::fullTime) ? 1 : 0;

        for (size_t nSex = 0; nSex < sexSize; nSex++) {

            // make some test value
            theSalarySex->acc[SalarySex::ACC_Count][nCell++] = 
                (double)(nSalary + nSex + i_model->subSampleNumber() + 1 + nFullBonus);
        }
        // "sex" dimension has total enabled: make test value for "total"
        theSalarySex->acc[SalarySex::ACC_Count][nCell++] =
            (double)(nSalary + 800 + i_model->subSampleNumber() + 1 + nFullBonus);
    }

    // trace output: disabled by default, use command-line or model.ini to enable it
    theTrace->logMsg("Event loop completed");
}

// Initialize model run: read parameters
void RunInit(IRunBase * const i_runBase)
{
    // load model parameters
    theLog->logMsg("Reading Parameters");
    i_runBase->readParameter("StartingSeed", typeid(int), 1, &startSeed);
    i_runBase->readParameter("ageSex", typeid(double), ageSize * sexSize, ageSex);
    i_runBase->readParameter("salaryAge", typeid(int), salarySize * ageSize, salaryAge);
    i_runBase->readParameter("salaryFull", typeid(int), salarySize, salaryFull);
    i_runBase->readParameter("baseSalary", typeid(int), 1, &baseSalary);
}

// Model startup method: initialize subsample
void ModelStartup(IModel * const i_model)
{
    theTrace->logMsg("Start model subsample");

    // clear existing output table(s) - release memory if allocated by previous run
    theSalarySex.reset(new SalarySex());

    // allocate and initialize new output table(s)
    theSalarySex->initialize_accumulators();
}

// Model shutdown method: write output tables
void ModelShutdown(IModel * const i_model)
{
    // write output result tables: salarySex sub-sample
    theLog->logMsg("Writing Output Tables");

    i_model->writeOutputTable(SalarySex::NAME, SalarySex::N_CELL, theSalarySex->acc_storage);
}

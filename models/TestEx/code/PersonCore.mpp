/*****************************************************************************
*	Modgen™ published by authority of the Minister responsible for 
*			   Statistics Canada.
*	© 1998-2000 Minister of Industry. 
*
*Revisions:
* +-----+----------+---------------------------------------------------------+
* | Who |   Date   | Description                                             |
* +-----+----------+---------------------------------------------------------+
* | SG  | 00/09/07 | Created as part of Compex model                         |
* | CC	| 07/09/14 | re-created from Simpex's Person module.  emptied it, 	 |
* |		|		   |	added code found in Compex, changed language code to |
* |		|		   |	EN													 |
* +-----+----------+---------------------------------------------------------+
******************************************************************************/

/* NOTE(Person, EN)
This file contains the Person-related events and functions.
*/


classification CASE_END {  //EN End of Case condition 
	DOMINANT_DEAD,   //EN Dominant Person dead 
	ALL_DEAD         //EN All case members dead 
};


classification SEX { //EN Gender 
	FEMALE, //EN Female 
	MALE	//EN Male 
};

range LIFE		{ 0, 49 };  	//EN duration of life 
range CASE48	{ 0, 47 };		//EN Case numbers
range SIMYEAR	{ 1970, 1980 }; //EN simulation year 
range DECADE    { 0, 10 }; 		//EN A decade of time

parameters {
/* NOTE(CaseEnd,EN) 
	This parameter controls whether the case ends when the
	dominant person is dead, or when all case members are dead. 
*/
	CASE_END CaseEnd; //EN end of case condition 
};


actor Person          //EN Individual
{
	/* 
		State variables required for this specific simulation.
		Note: the age variable is automatically generated by Modgen
	*/
	logical	age_spell 	= { TRUE };	//EN Single year of age spell
	logical	alive 		= { TRUE };	//EN Alive 

	// clone_number and clones_requested allow cloning capability.

	/* NOTE(Person.clone_number,EN)
		If this state is zero, then this is the first case.  Otherwise it is a clone.	
	*/
	int		clone_number;		//EN clone number 
	int		clones_requested;	//EN requested number of clones 

	LIFE  	curtate_age = {0};	//EN Integerized Age 
	LIFE  	t01_lag_curtate_age = {0};	//EN Integerized Age 
	DECADE  decade = COERCE(DECADE, curtate_age);
	
	TIME  	date_of_birth;		//EN Date of Birth 
	TIME  	date_of_death;		//EN Date of Death
	logical	dominant;			//EN Dominant 

	TIME  	next_birthday;		//EN Next Birthday 

	SEX   	 sex;              	//EN Sex 
	SIMYEAR  sim_year = COERCE(SIMYEAR,year);  //EN Simulation year

	int		year_of_birth;	   	//EN Year of birth 
	int		month_of_birth;		//EN Month of birth 
	int		day_of_birth;	  	//EN Day of birth 

	// ---- Variables used in testing ----
	double 	t01_change_var 	= {0};  	//EN Var. changes
	int 	T01_CHANGE_VAR = 3;	//EN Testing var See Test01

	// -----------------------------------

	CASE48 myCase = case_id < 48 ? case_id : 47;	//EN Case identifier to use in tables

	/*TODO - Add more states*/

	event timeBirthdayEvent, BirthdayEvent;   //EN The person's birthday
	event timeMortalityEvent, MortalityEvent; //EN The person's death

	/* Functions required by the simulation engine */
	void	Start( 
		     long lCase,
		     logical bDominant, 
	        TIME tBirth = TIME_INFINITE,
	        TIME tDeath = TIME_INFINITE,
			TIME tCurrent = TIME_INFINITE,
	        SEX eSex = MALE,
	        int nCloneNumber = 0,
	        int nClonesRequested = 0 ); //EN Function which starts the person actor 

	void StartClockHere();			      //EN Start Clock dummy function (for hooking)
	void Finish();

	long case_number;
};

// =====================================================================
// Control functions for the person actor:
// Each actor in Modgen must be "created" at the beginning of the simulation
// and "destroyed" at the end of the simulation.
// These functions can be empty and still do the job.

// create a person for the simulation
void Person::Start( long lCase, logical bDominant, TIME tBirth, TIME tDeath, TIME tCurrent, SEX eSex, int nCloneNumber, int nClonesRequested )
{
    // Initialize all attributes (OpenM++).
    initialize_attributes();

	//It is the responsibility of the calling function to ensure tcurrent >= tBirth
	case_number 	= lCase; // Capture the case number
	time 			= tCurrent;

	StartClockHere();

	age 	 		= tCurrent - tBirth;
	curtate_age 	= int(age);
	sex 	 		= eSex;
	dominant 		= bDominant;
	date_of_birth 	= tBirth;
	date_of_death 	= tDeath;

	year_of_birth 	= year;
	month_of_birth 	= month_of_year;
	day_of_birth 	= day_of_month;

	next_birthday 	 = (tCurrent == tBirth) ? tCurrent : TIME(tCurrent + (1- fmod(age, 1)));
	clone_number 	 = nCloneNumber;
	clones_requested = nClonesRequested;

    // hooked function call location (OpenM++)
    hook_Start();

    // Have the entity enter the simulation (OpenM++).
    enter_simulation();
}


/* NOTE(Person.StartClockHere,EN) 
	This function has no code.  It is present in order to specify a location to which to hook the StartClock function.
	Hooking StartClock just after the time variable is initialized in Person::Start allows subsequent initialization code
	to use the Clock states.
*/
void Person::StartClockHere()
{
    // hooked function call location (OpenM++)
    hook_StartClockHere();
}

extern void signal_exit_simulation_all();

// destroy a person upon the completion of the lifetime
void Person::Finish()
{

    // hooked function call location (OpenM++)
    hook_Finish();

    // Tell the simulation framework to finish the case if this is the dominant person
    if (dominant) {
        signal_exit_simulation_all();
    }

    // Have the entity exit the simulation (OpenM++).
    exit_simulation();
}

/* NOTE(Person.BirthdayEvent,EN)
	This event occurs at each birthday and increases the age of the
	person. 
*/
TIME Person::timeBirthdayEvent()
{
	return next_birthday;
}

void Person::BirthdayEvent()
{
	age_spell = FALSE;
	if ( age > 0 && age < MAX(LIFE) ) {
		curtate_age++;
		t01_lag_curtate_age++; // Test01, increments but just lags curtate_age
	}
	if ( age == T01_CHANGE_VAR ) {
		t01_change_var = 3; // Test01, first changes()
	}
	
	age_spell = TRUE;

	next_birthday += (TIME) 1;

    // hooked function call location (OpenM++)
    hook_BirthdayEvent();
}

TIME Person::timeMortalityEvent()
{
	return date_of_death;
}

void Person::MortalityEvent()
{
	alive = FALSE;
	Finish();
}



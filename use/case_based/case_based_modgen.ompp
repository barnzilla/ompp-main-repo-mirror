/**
* @file    omSimulation_case_based.cpp
* Implementation of framework for case-based models
*
*/
// Copyright (c) 2013 OpenM++
// This code is licensed under MIT license (see LICENSE.txt for details)

parameters {
    //EN Simulation starting seed
    int SimulationSeed;

    //EN Simulation cases
    long long SimulationCases;
};

use "common.ompp";

/**
 * The fmk namespace is used within this module
 * to protect the global namespace for model use.
 */
namespace fmk {

    // Fixed number of randome number generators available in Modgen
    const int max_samples = 41;

    // Fixed modulus used by all Modgen random number generators
    const long mg_modulus = 2147483647;

    // Multiplier of generator used to generate the starting seeds for each case
    const long case_seed_generators[max_samples] = {
        470583131,
        1278375574,
        1182424016,
        465267208,
        236156608,
        507096703,
        1030737213,
        1192442634,
        286354484,
        1963413634,
        929285805,
        1074439303,
        1866718706,
        1746251423,
        444178200,
        1076542630,
        289753891,
        490363125,
        803959450,
        37939113,
        1153920361,
        1010788020,
        1148043095,
        1422167303,
        1596996927,
        396692538,
        2125924067,
        290525234,
        1412033687,
        70608958,
        366654164,
        29727326,
        40186327,
        1271122795,
        940165244,
        735279377,
        1988769561,
        988683283,
        1943943356,
        1294875557,
        914624015,
    };

    // Multiplier of generator used to initialize the model stream seeds
    const long model_stream_seed_generator = 376740290;

    // Multiplier of generator used for a given 'sample member'
    const long model_stream_generators[max_samples] = {
        16807,
        1826645050,
        519701294,
        1912518406,
        87921397,
        755482893,
        673205363,
        727452832,
        630360016,
        1142281875,
        219667202,
        200558872,
        1185331463,
        573186566,
        396907481,
        1106264918,
        1605529283,
        1902548864,
        1444095898,
        1600915560,
        1987505485,
        1323051066,
        1715488211,
        1289290241,
        967740346,
        1644645313,
        2142074246,
        1397488348,
        97473033,
        1210640156,
        990191797,
        640039787,
        1141672104,
        2081478048,
        1236995837,
        1985494258,
        84845685,
        184528125,
        1303680654,
        61496220,
        1096609123,
    };

    // Maximum number of streams in the model (increase if insufficient)
    const int model_streams = 100;

    // Current seed for each stream generator in the model
    long model_stream_seeds[model_streams];

    // Multiplier for the generator for the streams in the model (shared by all streams)
    long model_stream_generator = 0;

    // Is there a random normal in other_normal?
    bool other_normal_valid = false;

    // THe other normal draw
    double other_normal;

} // fmk

double RandUniform(int strm)
{
    assert(strm < fmk::model_streams);
    long seed = fmk::model_stream_seeds[strm];
    long long product = fmk::model_stream_generator;
    product *= seed;
    seed = product % fmk::mg_modulus;
    fmk::model_stream_seeds[strm] = seed;
    return (double)seed / (double)fmk::mg_modulus;
}

double RandNormal(int strm)
{
    assert(strm < fmk::model_streams);

    if (fmk::other_normal_valid) {
        fmk::other_normal_valid = false;
        return fmk::other_normal;
    }
    else {
        double r2 = 1;
        double x = 0;
        double y = 0;
        while (r2 >= 1) {
            x = 2.0 * RandUniform(strm) - 1.0;
            y = 2.0 * RandUniform(strm) - 1.0;
            r2 = x * x + y * y;
        }
        double scale = sqrt(-2.0 * log(r2) / r2);
        double n1 = scale * x;
        double n2 = scale * y;
        fmk::other_normal = n2;
        fmk::other_normal_valid = true;
        return n1;
    }
}


void RunModel(IModel * i_model)
{
    theLog->logMsg("Running Simulation");

    // The number of simulations in the sample of simulations (not used)
    int sample_size = i_model->subSampleCount();

    // The member to simulate of the sample of simulations
    int sample_member = i_model->subSampleNumber();

    int seed = SimulationSeed; // framework input parameter
    long long cases = SimulationCases; // framework input parameter

    // for sample numbers greater than maximum, re-use generators cyclically
    // and increment the starting case_seed for the simulation of the sample
    long case_seed = seed + (int)sample_member / fmk::max_samples;
    long case_seed_generator = fmk::case_seed_generators[sample_member % fmk::max_samples];

    // For sample_member numbers greater than limit, re-use generators cyclically.
    fmk::model_stream_generator = fmk::model_stream_generators[sample_member % fmk::max_samples];

    for (long long thisCase = 0; thisCase < cases; thisCase++) {

        {
            // initialize the stream generators
            long seed = case_seed;
            for (int model_stream = 0; model_stream < fmk::model_streams; model_stream++) {
                fmk::model_stream_seeds[model_stream] = seed;
                long long product = fmk::model_stream_seed_generator;
                product *= seed;
                seed = product % fmk::mg_modulus;
            }
        }

        // Initialize global event counter for the case
        BaseEvent::global_event_counter = 0;

        // Initialize global time for the case  (can override in StartSimulation)
        BaseEvent::global_time = 0;

        // Prepare the case for simulation
        ::StartSimulation(); // Model-specific - normlly defined in Framework.ompp

        // Simulate the case
        while (BaseEvent::do_next_event());

        // Debug check for no left-over agents for which Finish was not called (model error)
        assert(0 == BaseAgent::om_active_agents());

        ::EndSimulation(); // Model-specific - normally defined in Framework.ompp

        {
            // generate the case seed for the next case
            long long product = case_seed_generator;
            product *= case_seed;
            case_seed = product % fmk::mg_modulus;
        }
    } // cases
}


/**
* @file    case_based_common.ompp
* Implementation of framework for case-based models
*
*/
// Copyright (c) 2013-2015 OpenM++
// This code is licensed under the MIT license (see LICENSE.txt for details)

parameters {
    //EN Simulation starting seed
    int SimulationSeed;

    //EN Simulation cases
    long long SimulationCases;
};

/**
 * The fmk namespace protects the global namespace for model use.
 */
namespace fmk {

    /**
     * Helper function to output a case checksum message to the trace log.
     * 
     * @param case_seed     The case seed.
     * @param case_sample   The case sample.
     */
    void case_checksum_msg(double case_seed, int case_sample)
    {
        theTrace->logFormatted("Case seed : %.0f\t-\tCase sample: %d\t-\tCheckSum : %.6f",
                           case_seed,
                           case_sample,
                           BaseEvent::get_event_checksum());
    }

    /**
     * The total number of cases to simulate, over all sample members.
     */
    long long all_cases = 0;

    /**
     * The number of cases to simulate in this member.
     */
    thread_local long long member_cases = 0;

    /**
     * The case seed encoded, with high order bits containing the sample member id.
     */
    thread_local double case_seed_encoded = 0.0;

    /**
     * The case counter in this simulation member.
     */
    thread_local long long member_case_counter = 0;

} // fmk

/**
 * Gets the numeric case identifier of the current case.
 * 
 * See Modgen Developer's Guide. The case identifier is unique, sequential, and starts at 0.
 * Values are interleaved among simulation members.  For example, if there are 4 simulation
 * members, member 0 would have case identifiers 0,4,8,... member 1 would have case identifiers 1,5,9,...
 *
 * @return The case identifier.
 */
long long GetCaseID()
{
    return fmk::member_case_counter * fmk::simulation_members + fmk::simulation_member;
}

/**
 * Gets the case seed of the current case (encoded with sample number).
 * 
 * See Modgen Developer's Guide.
 *
 * @return The case seed.
 */
double GetCaseSeed()
{
    return fmk::case_seed_encoded;
}

/**
 * Gets the sample number of the current case.
 *
 * See Modgen Developer's Guide.
 *
 * @return The case sample.
 */
int GetCaseSample()
{
    return fmk::simulation_member;
}

/**
 * Gets the sample number of the current call to UserTable
 *
 * See Modgen Developer's Guide.
 *
 * @return The case sample.
 */
int GetUserTableSubSample()
{
    return fmk::simulation_member;
}

/**
 * Gets the total number of cases, summed over all samples.
 *
 * See Modgen Developer's Guide.
 *
 * @return all cases.
 */
long long GetAllCases()
{
    return fmk::all_cases;
}

/**
 * Gets the number of "sub-samples" in the simulation.
 *
 * See Modgen Developer's Guide.
 *
 * @return The sub samples.
 */
int GetSubSamples()
{
    return fmk::simulation_members;
}

/**
 * Gets case counter in thread.
 *
 * @return The case counter in thread.
 */
long long GetCaseCounterInThread()
{
    return fmk::member_case_counter;
}

void SimulateEvents()
{
    // Simulate the case
    while (true) {
        if (fmk::do_exit_simulation_all) {
            // The previous event signalled to end the simulation
            BaseAgent::exit_simulation_all();
            break;
        }
        if (!BaseEvent::do_next_event()) {
            // no more events
            break;
        }
    }
}

/**
 * Simulates the specified simulation member (sub-sample)
 *
 * @param mem_id    Identifier of the member to be simulated (sub-sample).
 * @param mem_count Total number of members (sub-samples).
 */
void RunSimulation(int mem_id, int mem_count)
{
    // The following functions are usually defined in the main simulation module, e.g. model.mpp
    // case_info is usually declared in the model-specific include file custom_early.h
    extern void Simulation_start(case_info &ci);
    extern void Simulation_end(case_info &ci);
    extern void CaseSimulation(case_info &ci);

    using namespace fmk;

    // Initialize the entity counter for this simulation member
    member_entity_counter = 0;

    // Create the case information communication object
    case_info ci;

    // Initialize CaseInfo API
    CaseInfo(&ci);

	// Perform operations at the start of Simulation
	Simulation_start(ci);

    string msg = "Running Simulation - member=" + to_string(mem_id);
    theLog->logMsg(msg.c_str());

    // The number of member simulations in the sample of simulations
    simulation_members = mem_count;

    // The member to simulate of the sample of simulations
    simulation_member = mem_id;

    int seed = SimulationSeed; // framework input parameter
    all_cases = SimulationCases; // framework input parameter

    // The number of cases to simulate for this sample member.
    // Divide the total cases for the entire simulation by the number of members
    // and spread any cases in the remainder among the first members (one extra case each)
    member_cases = all_cases / simulation_members;
    if (simulation_member < (all_cases % simulation_members)) {
        member_cases++;
    };

    // For simulation member values greater than the (Modgen) maximum, re-use case seed generators cyclically
    // and increment the starting case_seed for the simulation of the sample.
    long case_seed = seed + (int)simulation_member / max_case_seed_generators;
    long case_seed_generator = case_seed_generators[simulation_member % max_case_seed_generators];

	// Create stream generator objects
	new_streams();

    for (long long thisCase = 0; thisCase < member_cases; thisCase++) {
        {
            // initialize the stream generators in the case, based on the simulation member and case seed
            long seed = case_seed;
            for (int model_stream = 0; model_stream < model_streams; model_stream++) {
                initialize_stream(model_stream, simulation_member, seed);
				// use specific fixed integral-congruential generator (with multiplier model_stream_seed_generator) to create seeds for streams
                long long product = model_stream_seed_generator;
                product *= seed;
                seed = product % mg_modulus;
            }
        }

        // Initialize global time for the case  (can override in StartSimulation)
        BaseEvent::set_global_time(0);

        // record the encoded case seed (case_seed + simulation_member in high order bits)
        case_seed_encoded = case_seed + simulation_member * ((double)mg_modulus + 1);

        // record the case counter within the current simulation member
        member_case_counter = thisCase;

        // Reset the running event checksum
        BaseEvent::event_checksum_reset();

        // Simulate the case
        CaseSimulation(ci);

        // Log the case checksum if activated
        if (BaseEvent::event_checksum_enabled) case_checksum_msg(case_seed, simulation_member);

        // Debug check for no left-over agents for which Finish was not called (model error)
        assert(0 == BaseAgent::om_active_agents());

        if (fmk::do_exit_simulation_all) {
            // The model signalled to end the simulation
            break;
        }

        {
            // generate the case seed for the next case
            long long product = case_seed_generator;
            product *= case_seed;
            case_seed = product % mg_modulus;
        }
    } // cases

	// Perform operations at the end of Simulation
	Simulation_end(ci);

	// Free stream generator objects
	delete_streams();

    // Reset CaseInfo API
    CaseInfo(nullptr, true);
}

case_info* CaseInfo(case_info* ci, bool reset)
{
    static thread_local case_info* ci_stored = nullptr;

    if (reset) {
        ci_stored = nullptr;
    }
    else if (ci) {
        ci_stored = ci;
    }
    return ci_stored;
}

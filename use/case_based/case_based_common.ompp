/**
* @file    case_based_common.ompp
* Implementation of framework for case-based models
*
*/
// Copyright (c) 2013-2016 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

parameters {
    //EN Simulation starting seed
    int SimulationSeed;

    //EN Simulation cases
    long long SimulationCases;
};

/**
 * The fmk namespace protects the global namespace for model use.
 */
namespace fmk {

    /**
     * Helper function to output a case checksum message to the trace log.
     * 
     * @param case_seed     The case seed.
     * @param case_sample   The case sample.
     */
    void case_checksum_msg(double case_seed, int case_sample)
    {
        // The case checksum format reproduces the Modgen format precisely.
        theTrace->logFormatted("Case seed : %.0f\t-\tCase sample: %d\t-\tCheckSum : %.6f",
                           GetCaseSeed(),
                           case_sample,
                           BaseEvent::get_event_checksum());
    }

    /**
     * The total number of cases to simulate, over all sample members.
     */
    long long all_cases = 0;

    /**
     * The number of cases to simulate in this member.
     */
    thread_local long long member_cases = 0;

    /**
     * The case counter in this simulation member.
     */
    thread_local long long member_case_counter = 0;

} // namespace fmk

/**
* Called before invocation of PreSimulation functions.
*/
void before_presimulation(int mem_id, int mem_count)
{
    // The number of member simulations in the sample of simulations
    fmk::simulation_members = mem_count;

    // The member to simulate of the sample of simulations
    fmk::simulation_member = mem_id;

    // In PreSimulation, the master seed is the same for all simulation members.
    // For lcg-style generators, a different generator is used for each member.
    // For other generators, the actual starting seed is generated from the master seed
    // and the simulation member number.
    fmk::master_seed = SimulationSeed;

    // Create stream generator objects
    // new_streams is generator-specific - defined in random/random_YYY.ompp
    new_streams();

    // Note that streams vary by simulation member as well as SimulationSeed and stream number.
    initialize_model_streams(); //defined in common.ompp
}

/**
* Called after invocation of PreSimulation functions.
*/
void after_presimulation()
{
    fmk::master_seed = 0;

    // Free stream generator objects
    // delete_streams is generator-specific - defined in random/random_YYY.ompp
    delete_streams();
}

/**
 * Gets the numeric case identifier of the current case.
 * 
 * See Modgen Developer's Guide. The case identifier is unique, sequential, and starts at 0.
 * Values are interleaved among simulation members.  For example, if there are 4 simulation
 * members, member 0 would have case identifiers 0,4,8,... member 1 would have case identifiers 1,5,9,...
 *
 * @return The case identifier.
 */
long long GetCaseID()
{
    return fmk::member_case_counter * fmk::simulation_members + fmk::simulation_member;
}

/**
 * Gets the case seed of the current case (encoded with sample number).
 * 
 * See Modgen Developer's Guide.
 *
 * @return The case seed.
 */
double GetCaseSeed()
{
    return (double) get_combined_seed();
}

/**
 * Gets the sample number of the current case.
 *
 * See Modgen Developer's Guide.
 *
 * @return The case sample.
 */
int GetCaseSample()
{
    return fmk::simulation_member;
}

/**
 * Gets the sample number of the current call to UserTable
 *
 * See Modgen Developer's Guide.
 *
 * @return The case sample.
 */
int GetUserTableSubSample()
{
    return fmk::simulation_member;
}

/**
 * Gets the total number of cases, summed over all samples.
 *
 * See Modgen Developer's Guide.
 *
 * @return all cases.
 */
long long GetAllCases()
{
    return fmk::all_cases;
}

/**
 * Gets the number of "sub-samples" in the simulation.
 *
 * See Modgen Developer's Guide.
 *
 * @return The sub samples.
 */
int GetSubSamples()
{
    return fmk::simulation_members;
}

/**
 * Sets the weight of all entities in a case.
 * 
 * See Modgen Developer's Guide. Entity weighting is not yet implemented in ompp. A call to this
 * function will cause a run-time fatal error if weight is not equal to 1.0.
 *
 * @param weight The weight.
 */
void SetCaseWeight(double weight)
{
    if (weight == 1.0) {
        return;
    }
    std::stringstream ss;
    ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
       << LT("error : Entity weight not implemented.  Argument to SetCaseWeight must be 1.0, is ") << weight
       ;
    ModelExit(ss.str().c_str());
}

/**
 * Gets case counter in thread.
 *
 * @return The case counter in thread.
 */
long long GetCaseCounterInThread()
{
    return fmk::member_case_counter;
}

void Set_actor_weight(double weight)
{
    // not implemented
    // TODO emit run-time warning once 
}

void Set_actor_subsample_weight(double weight)
{
    // not implemented
    // TODO emit run-time warning once 
}

void SimulateEvents()
{
    // Simulate the case
    while (true) {
        if (!BaseEvent::do_next_event()) {
            // no more events
            break;
        }
    }
}

/**
 * Simulates the specified simulation member (sub-sample)
 *
 * @param mem_id    Identifier of the member to be simulated (sub-sample).
 * @param mem_count Total number of members (sub-samples).
 */
void RunSimulation(int mem_id, int mem_count, IModel * const i_model)
{
    // The following functions are usually defined in the main simulation module, e.g. model.mpp
    // case_info is usually declared in the model-specific include file custom_early.h
    extern void Simulation_start(case_info &ci);
    extern void Simulation_end(case_info &ci);
    extern void CaseSimulation(case_info &ci);

    using namespace fmk;

    // note API object for subsequent use in modeling thread
    fmk::i_model = i_model;

    // Initialize the entity counter for this simulation member
    member_entity_counter = 0;

    // The number of member simulations in the sample of simulations
    simulation_members = mem_count;

    // The member to simulate of the sample of simulations
    simulation_member = mem_id;

    report_simulation_progress(simulation_member, 0);

    // number of progress reporting steps
    const int progress_steps = 10;
    // current reporting step
    int current_step = 0;

    // Create the case information communication object
    case_info ci;

    // Initialize CaseInfo API
    CaseInfo(&ci);

	// Perform operations at the start of Simulation
	Simulation_start(ci);

    all_cases = SimulationCases; // framework input parameter

    // The number of cases to simulate for this sample member.
    // Divide the total cases for the entire simulation by the number of members
    // and spread any cases in the remainder among the first members (one extra case each)
    member_cases = all_cases / simulation_members;
    if (simulation_member < (all_cases % simulation_members)) {
        member_cases++;
    };

    // For simulation member values greater than the number of lcg generators,
    // re-use case seed generators cyclically and increment the starting
    // master_seed for the simulation of the sample.
    fmk::master_seed = SimulationSeed + (int)simulation_member / max_case_seed_generators;
    long case_seed_generator = case_seed_generators[simulation_member % max_case_seed_generators];

	// Create stream generator objects
	// new_streams is generator-specific - defined in random/random_YYY.ompp
	new_streams();

    for (long long thisCase = 0; thisCase < member_cases; thisCase++) {

        initialize_model_streams(); //defined in common.ompp

        // Initialize global time for the case (can override in StartSimulation)
        BaseEvent::set_global_time(0);

        // record the encoded case seed (case_seed + simulation_member in high order bits)
        fmk::combined_seed = fmk::master_seed + simulation_member * ((long long)lcg_modulus + 1);

        // record the case counter within the current simulation member
        member_case_counter = thisCase;

        // Reset the running event checksum
        BaseEvent::event_checksum_reset();

        // Simulate the case
        CaseSimulation(ci);

        // Log the case checksum if activated
        if (BaseEvent::event_checksum_enabled) case_checksum_msg(fmk::master_seed, simulation_member);

        // Debug check for no left-over agents for which Finish was not called (possible model error)
        // TODO - consider making an optional warning activated by a model option
        //  which could be turned on/off.
        assert(0 == BaseAgent::om_active_agents());

        // cleanup entities and event queue after case has completed.
        BaseAgent::exit_simulation_all();
        BaseEvent::clean_all();
        BaseAgent::free_all_zombies();

        {
            // generate the master seed for the next case
            long long product = case_seed_generator;
            product *= fmk::master_seed;
            fmk::master_seed = product % lcg_modulus;
        }

        // Compute progress and report periodically
        {
            double progress_fraction = (double)thisCase / (double)member_cases;
            int the_step = (int)(progress_fraction * progress_steps);
            if (the_step > current_step) {
                // Note that rapid progress can skip over steps.
                current_step = the_step;
                int percent_done = (100 / progress_steps) * current_step;
                report_simulation_progress(simulation_member, percent_done);
            };
        }
    } // cases

	// Perform operations at the end of Simulation
	Simulation_end(ci);

	// Free stream generator objects
	// delete_streams is generator-specific - defined in random/random_YYY.ompp
	delete_streams();

    // Reset CaseInfo API
    CaseInfo(nullptr, true);

    if (current_step < progress_steps) {
        // final progress message
        report_simulation_progress(simulation_member, 100);
    }
}

case_info* CaseInfo(case_info* ci, bool reset)
{
    static thread_local case_info* ci_stored = nullptr;

    if (reset) {
        ci_stored = nullptr;
    }
    else if (ci) {
        ci_stored = ci;
    }
    return ci_stored;
}

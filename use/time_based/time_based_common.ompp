/**
* @file    time_based_common.ompp
* Implementation of framework for time-based models
* 
*/
// Copyright (c) 2013-2016 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

parameters {
    //EN Simulation starting seed
    int SimulationSeed;

    //EN Simulation end time
    Time SimulationEnd;
};

namespace fmk {

    /**
     * The simulation end.
     */
    Time simulation_end;

} // namespace fmk

double GetCaseSeed()
{
    // Time-based models have no concept of case seed.
    // Return 0 for compatibility with Modgen trace output.
    // and for run-time errors or warnings.
    return 0;
}

/**
 * Gets the replicate.
 *
 * See Modgen Developer's Guide.
 *  
 * @return The replicate.
 */
int GetReplicate()
{
    return fmk::simulation_member;
}

/**
 * Gets the replicate.
 *
 * See Modgen Developer's Guide.
 *  
 * @return The replicate.
 */
int GetUserTableReplicate()
{
    return fmk::simulation_member;
}

/**
 * Gets the number of replicates.
 *
 * See Modgen Developer's Guide.
 *  
 * @return The number of replicates.
 */
int GetReplicates()
{
    return fmk::simulation_members;
}

void LogSimulationStart()
{
    // Default global start time
    BaseEvent::set_global_time(0);
    theLog->logFormatted("Member=%d create starting population", fmk::simulation_member);
}

double SIMULATION_END()
{
    return (double) SimulationEnd;
}

void Set_actor_weight(double weight)
{
    // Do nothing.
    // OpenM++ models use population scaling for time-based models
    // since entities in time-based models have identical weights.
}

void Set_actor_subsample_weight(double weight)
{
    // Do nothing.
    // OpenM++ models use population scaling for time-based models
    // since entities in time-based models have identical weights.
}

void SimulateEvents()
{
    using namespace fmk;

    bool is_first_event = true;
    Time time_first_event(0); // used to calculate progress

    // initial simulation progress message (0%)
    report_simulation_progress(simulation_member, 0);

    // number of progress reporting steps
    const int progress_steps = 10;
    // current reporting step
    int current_step = 0;

    // Simulate the population
    while ( true ) {
        if (fmk::do_exit_simulation_all) {
            // The previous event signalled to end the simulation
            BaseAgent::exit_simulation_all();
            fmk::do_exit_simulation_all = false;
            break;
        }

        // get the time of the next event in the event queue
        Time the_time = BaseEvent::time_next_event();

        if (is_first_event) {
            // Note the time of the first event to compute % progress subsequently
            time_first_event = the_time;
            is_first_event = false;
        }

        if (the_time > simulation_end) {
            // The next event would exceed the maximum simulation time
            BaseAgent::age_all_agents(simulation_end);
            BaseAgent::exit_simulation_all();
            break;
        }

        // Implement the event
        if (!BaseEvent::do_next_event()) {
            // no more events
            break;
        }

        // Compute progress and report periodically
        if (simulation_end - time_first_event > 0) {
            double progress_fraction = (the_time - time_first_event) / (simulation_end - time_first_event);
            int the_step = (int)(progress_fraction * progress_steps);
            if (the_step > current_step) {
                // Note that rapid progress can skip over steps.
                current_step = the_step;
                int percent_done = (100 / progress_steps) * current_step;
                report_simulation_progress(simulation_member, percent_done);
            };
        }
    }

    if (current_step < progress_steps) {
        // final progress message
        report_simulation_progress(simulation_member, 100);
    }
}

/**
 * Simulates the specified simulation member (replicate)
 *
 * @param mem_id    Identifier of the member to be simulated (replicate).
 * @param mem_count Total number of members (replicates).
 */
void RunSimulation(int mem_id, int mem_count)
{
    extern void CaseSimulation(); // defined elsewhere

    using namespace fmk;

    // Initialize the entity counter for this simulation member
    member_entity_counter = 0;

    // The number of simulations in the sample of simulations (not used)
    simulation_members = mem_count;

    // The member to simulate of the sample of simulations
    simulation_member = mem_id;

    int seed = SimulationSeed; // framework input parameter
    simulation_end = SimulationEnd; // framework input parameter

    // The master seed to simulate this member of the 'sample' of simulations
    long master_seed = seed + simulation_member;

    // record the encoded combined seed (master_seed + simulation_member in high order bits)
    combined_seed = master_seed + simulation_member * ((long long)mg_modulus + 1);

	// Create random stream generator objects
	new_streams();

    {
        // initialize the stream generators
        long seed = master_seed;
		// initialize the stream generators in the simulation, using the master seed
		for (int model_stream = 0; model_stream < model_streams; model_stream++) {
            initialize_stream(model_stream, simulation_member, seed);
			// use specific fixed integral-congruential generator (with multiplier model_stream_seed_generator) to create seeds for streams
			long long product = model_stream_seed_generator;
            product *= seed;
            seed = product % mg_modulus;
        }
    }
    // Initialize global time (can override in StartSimulation)
    BaseEvent::set_global_time(-time_infinite);
     
    // Model-specific
    Simulation();

	// Free random stream generator objects
	delete_streams();
}


/**
* @file    common.ompp
* Implementation of global functions for all models
* 
* The global functions in this module are declared in omSimulation.h.
* 
*/
// Copyright (c) 2013-2015 OpenM++
// This code is licensed under the MIT license (see LICENSE.txt for details)

namespace fmk {

    /**
     * The number of simulations in the sample of simulations (not used)
     */
    int simulation_members = 0;

    /**
     * The current simulation member.
     */
    thread_local int simulation_member = 0;

    /**
     * The value for population scaling.
     * 
     * Specified by model code through a call to SetPopulation() in a PreSimulation function.
     */
    long set_population_value = 0;

    /**
     * A signal flag to the framework to exit all entities from the simulation.
     * 
     * Set by model code through a call to signal_exit_simulation_all().
     */
    thread_local bool do_exit_simulation_all = false;
}

/**
 * Fatal exit from the model, with a message.
 * 
 * See Modgen Developer's Guide for more information.
 */
void ModelExit(const char* msg)
{
    theLog->logMsg(msg);
    exit(-1);
}

/**
 * In Modgen, displays a warning message in the UI.
 *
 * See Modgen Developer's Guide for more information.
 * 
 * @param fmt The format string
 */
void WarningMsg(const char* fmt, ...)
{
    // not implemented
}

/**
 * In Modgen, displays a progress message in the UI.
 *
 * See Modgen Developer's Guide for more information.
 * 
 * @param fmt The format string
 */
void ProgressMsg(const char* msg)
{
    // not implemented
}

/**
 * Communicates current simulation time to UI to display progress.
 *
 * See Modgen Developer's Guide for more information.
 * 
 * @param tm The time.
 */
void TimeReport(double tm)
{
    // not implemented
}

/**
 * Set maximum time for fixed-precision time operations.
 * 
 * See Modgen Developer's Guide for more information.
 */
void SetMaxTime(double max_value)
{
    fixed_precision_float<Time::type>::set_max(max_value);
}

/**
 * Start event trace.
 * 
 * See Modgen Developer's Guide for more information.
 */
void StartEventTrace()
{
    if (BaseEvent::trace_event_enabled) {
        BaseEvent::trace_event_on = true;
    }
}

/**
 * Stop event trace.
 * 
 * See Modgen Developer's Guide for more information.
 */
void StopEventTrace()
{
    if (BaseEvent::trace_event_enabled) {
        BaseEvent::trace_event_on = false;
    }
}

/**
 * Total number of threads used in simulation.
 * 
 * See Modgen Developer's Guide for more information.
 */
int GetThreads()
{
    return 1;
}

/**
 * Numeric identifier of current thread for current simulation
 * 
 * See Modgen Developer's Guide for more information.
 */
int GetThreadNumber()
{
    return 1;
}

/**
 * Sets the total population used for population scaling
 *
 * @param lPopulation The total population.
 */
void SetPopulation(long lPopulation)
{
    fmk::set_population_value = lPopulation;
}

/**
 * Tells the framework to exit all entities from the simulation after completion of the current event.
 */
void signal_exit_simulation_all()
{
    fmk::do_exit_simulation_all = true;
}


/**
 * Piece linear lookup.
 *
 * @param x  The x coordinate.
 * @param ax The array of x coordinates of the points
 * @param ay The array of y coordinates of the points
 * @param n  The number of x-y points
 *
 * @return The y value corresponding to x
 */
double PieceLinearLookup(double x, const double *ax, const double *ay, int n)
{
    double y = 0.0;

    if (x <= ax[0]) {
        y = ay[0];
    }
    else if (x >= ax[n - 1]) {
        y = ay[n - 1];
    }
    else {
        // a simple linear search
        for (int j = 1; j < n; ++j) {
            if (x <= ax[j]) {
                // interpolate
                y = ay[j - 1] + (ay[j] - ay[j - 1]) / (ax[j] - ax[j - 1]) * (x - ax[j - 1]);
                break;
            }
        }
    }
    return y;
}

/**
 * Query if the value x is a numeric quantity.
 * 
 * Used to determine if a table cell contains a numeric value, or is empty.
 *
 * @param x The double to be checked
 *
 * @return true if undefined, false if not.
 */
bool IsUndefined(double x)
{
    return std::isnan(x);
}
/**
* @file    common.ompp
* Implementation of global functions for all models
* 
* The global functions in this module are declared in omSimulation.h.
* 
*/
// Copyright (c) 2013-2015 OpenM++
// This code is licensed under the MIT license (see LICENSE.txt for details)

namespace fmk {

    /**
     * The number of simulations in the sample of simulations
     */
    int simulation_members = 0;

    /**
     * The current simulation member.
     */
    thread_local int simulation_member = 0;

    /**
     * The entity counter in this simulation member.
     */
    thread_local long member_entity_counter = 0;

    /**
     * The seed encoded, with high order bits containing the simulation member id.
     */
    thread_local long long combined_seed = 0;

    /**
     * The value for population scaling.
     * 
     * Specified by model code through a call to SetPopulation() in a PreSimulation function.
     */
    long set_population_value = 0;

    /**
     * A signal flag to the framework to exit all entities from the simulation.
     * 
     * Set by model code through a call to signal_exit_simulation_all().
     */
    thread_local bool do_exit_simulation_all = false;
}

/**
 * Gets the combined seed.
 * 
 * Returns long long instead of double returned by GetCaseSeed()
 * For case-based models, the case seed, for time-based models, the global seed.
 * For both, the simulation member is in high order bits.
 *
 * @return The seed, with the simulation member in high order bits
 */
long long get_combined_seed()
{
    // Time-based models have no concept of case seed.
    // Return 0 when used in common run-time errors or warnings.
    return fmk::combined_seed;
}

/**
 * Handles situation where time is running backwards within an entity.
 */
void handle_backwards_time(
    double the_event_time,
    double the_current_time, 
    int the_event, 
    int the_entity)
{
    // The time of this event is in the local past of the entity within which the event occurs.
    // This is an error in model logic.
    std::stringstream ss;
    ss << "Error - Event time " << the_event_time
        << " is earlier than current time " << the_current_time
        << " in simulation member " << get_simulation_member()
        << " in event " << the_event
        << " in entity_id " << the_entity
        << " with combined seed " << get_combined_seed()
        ;
    throw openm::SimulationException(ss.str().c_str());
}

/**
 * Handles situation where the maximum number of random streams is exceeded.
 */
void handle_streams_exceeded(
    int strm, 
    int model_streams)
{
    // The stream number exceeds the maximum number of streams.
    std::stringstream ss;
    ss << "Error - stream number " << strm
        << " exceeds the maximum number of streams " << model_streams << "."
        << " Increase the number of streams in ompp_framework.ompp."
        ;
    throw openm::SimulationException(ss.str().c_str());
}

/**
 * Gets total number of simulation members.
 *
 * @return The simulation members.
 */
int get_simulation_members()
{
    return fmk::simulation_members;
}

/**
 * Gets current simulation member.
 *
 * @return The simulation member.
 */
int get_simulation_member()
{
    return fmk::simulation_member;
}

/**
 * Gets the next entity identifier.
 * 
 * As a side-effect, increments the counter of entities in the simulation member. The entity_id
 * is constructed to be unique both within and across simulation members, with a minimum value
 * of 1.
 *
 * @return The next entity identifier.
 */
int get_next_entity_id()
{
    fmk::member_entity_counter++;
    return fmk::member_entity_counter * fmk::simulation_members + fmk::simulation_member;
}


/**
 * Fatal exit from the model, with a message.
 * 
 * See Modgen Developer's Guide for more information.
 */
void ModelExit(const char* msg)
{
    theLog->logMsg(msg);
    throw openm::SimulationException(msg);
}

/**
 * Report simulation progress.
 * 
 */
void report_simulation_progress(int member, int percent)
{
    std::string msg = "Member=" + std::to_string(member) + " simulation progress=" + std::to_string(percent) + "%";
    theLog->logMsg(msg.c_str());
}


/**
 * In Modgen, displays a progress message in the UI.
 *
 * See Modgen Developer's Guide for more information.
 * Not used in ompp.
 * 
 * @param fmt The format string
 */
void ProgressMsg(const char* msg)
{
    // not implemented
}

/**
 * In Modgen, communicates current simulation time to UI to display progress.
 *
 * See Modgen Developer's Guide for more information.
 * Not used in ompp.
 * 
 * @param tm The time.
 */
void TimeReport(double tm)
{
    // not implemented
}

/**
 * Set maximum time for fixed-precision time operations.
 * 
 * See Modgen Developer's Guide for more information.
 */
void SetMaxTime(double max_value)
{
    fixed_precision_float<Time::type>::set_max(max_value);
}

/**
 * Start event trace.
 * 
 * See Modgen Developer's Guide for more information.
 */
void StartEventTrace()
{
    if (BaseEvent::trace_event_enabled) {
        BaseEvent::trace_event_on = true;
    }
}

/**
 * Stop event trace.
 * 
 * See Modgen Developer's Guide for more information.
 */
void StopEventTrace()
{
    if (BaseEvent::trace_event_enabled) {
        BaseEvent::trace_event_on = false;
    }
}

/**
 * Total number of threads used in simulation.
 * 
 * See Modgen Developer's Guide for more information.
 */
int GetThreads()
{
    return 1;
}

/**
 * Numeric identifier of current thread for current simulation
 * 
 * See Modgen Developer's Guide for more information.
 */
int GetThreadNumber()
{
    return 1;
}

/**
 * Sets the total population used for population scaling
 *
 * @param lPopulation The total population.
 */
void SetPopulation(long lPopulation)
{
    fmk::set_population_value = lPopulation;
}

/**
 * Tells the framework to exit all entities from the simulation after completion of the current event.
 */
void signal_exit_simulation_all()
{
    fmk::do_exit_simulation_all = true;
}


/**
 * Piece linear lookup.
 *
 * @param x  The x coordinate.
 * @param ax The array of x coordinates of the points
 * @param ay The array of y coordinates of the points
 * @param n  The number of x-y points
 *
 * @return The y value corresponding to x
 */
double PieceLinearLookup(double x, const double *ax, const double *ay, int n)
{
    double y = 0.0;

    if (x <= ax[0]) {
        y = ay[0];
    }
    else if (x >= ax[n - 1]) {
        y = ay[n - 1];
    }
    else {
        // a simple linear search
        for (int j = 1; j < n; ++j) {
            if (x <= ax[j]) {
                // interpolate
                y = ay[j - 1] + (ay[j] - ay[j - 1]) / (ax[j] - ax[j - 1]) * (x - ax[j - 1]);
                break;
            }
        }
    }
    return y;
}

/**
 * Query if the value x is a numeric quantity.
 * 
 * Used to determine if a table cell contains a numeric value, or is empty.
 *
 * @param x The double to be checked
 *
 * @return true if undefined, false if not.
 */
bool IsUndefined(double x)
{
    return std::isnan(x);
}
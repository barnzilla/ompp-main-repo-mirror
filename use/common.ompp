/**
* @file    common.ompp
* Implementation of global functions for all models
* 
* The global functions in this module are declared in omSimulation.h.
* 
*/
// Copyright (c) 2013-2017 OpenM++ Contributors
// This code is licensed under the MIT license (see LICENSE.txt for details)

namespace fmk {

    /**
     * The number of simulations in the sample of simulations
     */
    int simulation_members = 0;

    /**
     * The current simulation member.
     */
    thread_local int simulation_member = 0;

    /**
     * The entity counter in this simulation member.
     */
    thread_local long member_entity_counter = 0;

    /**
     * The modulus used by linear congruential random number generators.
     * Equal to 2^31 - 1
     */
    const long lcg_modulus = 2147483647;

    /**
     * Multiplier of linear congruential generator used to initialize model stream seeds.
     */
    const long model_stream_seed_generator = 376740290;

    /**
     * The master seed encoded, with high order bits containing the simulation member id.
     *
     * The random number generators can vary by simulation member, so both
     * master seed and simulation member are required to reproduce
     * a case (for case-based models) or a replicate (for time-based models)
     * independtly of other cases / replicates.
     */
    thread_local long long combined_seed = 0;

    /**
     * The master seed, derived from the parameter SimulationSeed.
     *
     * The master seed is used to seed the individual random streams
     * in the model before simulating a case (for case-based models)
     * or simulating a member (aka replicate) (for time-based models).
     * It is also used to seed the individual random number streams
     * before execution of PreSimulation functions.
     *
     * For case-based models, the master seed is used for a case,
     * and is set by a separate case seed random number generator.
     *
     * For time-based models, the master seed is used for a member (aka replicate),
     * and is set to SimulationSeed.
     *
     * For use in PreSimulation functions,
     * the master seed is set to SimulationSeed.
     *
     * The actual RNG stream varies by member, in an RNG-specific way.
     */
    thread_local long master_seed = 0;

    /**
     * The value for population scaling.
     * 
     * Specified by model code through a call to SetPopulation() in a PreSimulation function.
     */
    long set_population_value = 0;

    /**
     * A signal flag to the framework to exit all entities from the simulation.
     * 
     * Set by model code through a call to signal_exit_simulation_all().
     * NB: DEPRECATED - not needed or useful in ompp design
     */
    thread_local bool do_exit_simulation_all = false;
}

/**
 * Gets the combined seed.
 * 
 * Returns long long instead of double returned by GetCaseSeed()
 * For case-based models, the case seed, for time-based models, the global seed.
 * For both, the simulation member is encoded in high order bits.
 *
 * @return The seed, with the simulation member in high order bits
 */
long long get_combined_seed()
{
    return fmk::combined_seed;
}

/**
 * Initializes the model stream generators
 *
 * For case-based models, the stream generators are initialized for each case.
 * For time-based models, the stream generators are initialized for each member (aka replicate)
 */
void initialize_model_streams()
{
    using namespace fmk;

    long stream_seed = fmk::master_seed;
    for (int model_stream = 0; model_stream < model_streams; model_stream++) {
        // initialize_stream is generator-specific - defined in random/random_YYY.ompp.
        // Note that streams vary by simulation_member as well as stream_seed.
        initialize_stream(model_stream, simulation_member, stream_seed);
		// Use fixed integral-congruential generator (with multiplier model_stream_seed_generator)
		// to create seeds for streams.
        long long product = model_stream_seed_generator;
        product *= stream_seed;
        stream_seed = product % lcg_modulus;
    }
}

/**
 * Handles situation where time is running backwards within an entity.
 */
void handle_backwards_time(
    double the_event_time,
    double the_current_time, 
    int the_event, 
    int the_entity)
{
    // The time of this event is in the local past of the entity within which the event occurs.
    // This is an error in model logic.
    extern const char * event_id_to_name(int event_id); // omc generated function defined in om_definitions.cpp
    std::stringstream ss;
    ss  << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
        << LT("error : Event time ") << std::showpoint << the_event_time
        << LT(" is earlier than current time ") << the_current_time
        << LT(" in event ") << event_id_to_name(the_event)
        << LT(" in entity_id ") << the_entity
        << LT(" in simulation member ") << get_simulation_member()
        << LT(" with combined seed ") << get_combined_seed()
        ;
    ModelExit(ss.str().c_str());
}

/**
 * Handles situation where the maximum number of random streams is exceeded.
 */
void handle_streams_exceeded(
    int strm, 
    int model_streams)
{
    // The stream number exceeds the maximum number of streams.
    std::stringstream ss;
    ss  << LT("error : stream number ") << strm
        << LT(" exceeds the maximum number of streams ") << model_streams << LT(".")
        << LT(" Increase the number of streams in ompp_framework.ompp.")
        ;
    ModelExit(ss.str().c_str());
}

/**
 * Gets total number of simulation members.
 *
 * @return The simulation members.
 */
int get_simulation_members()
{
    return fmk::simulation_members;
}

/**
 * Gets current simulation member.
 *
 * @return The simulation member.
 */
int get_simulation_member()
{
    return fmk::simulation_member;
}

/**
 * Gets the next entity identifier.
 * 
 * As a side-effect, increments the counter of entities in the simulation member. The entity_id
 * is constructed to be unique both within and across simulation members, with a minimum value
 * of 1.
 *
 * @return The next entity identifier.
 */
int get_next_entity_id()
{
    fmk::member_entity_counter++;
    return fmk::member_entity_counter * fmk::simulation_members + fmk::simulation_member;
}


/**
 * Fatal exit from the model, with a message.
 * 
 * See Modgen Developer's Guide for more information.
 */
void ModelExit(const char* msg)
{
    theLog->logMsg(msg);
    throw openm::SimulationException(msg);
}

/**
 * Report simulation progress.
 * 
 */
void report_simulation_progress(int member, int percent)
{
    theLog->logFormatted("Member=%d simulation progress=%d%%", member, percent);
}


/**
 * In Modgen, displays a progress message in the UI.
 *
 * See Modgen Developer's Guide for more information.
 * Not used in ompp.
 * 
 * @param fmt The format string
 */
void ProgressMsg(const char* msg)
{
    // not implemented
}

/**
 * In Modgen, communicates current simulation time to UI to display progress.
 *
 * See Modgen Developer's Guide for more information.
 * Not used in ompp.
 * 
 * @param tm The time.
 */
void TimeReport(double tm)
{
    // not implemented
}

/**
 * Set maximum time for fixed-precision time operations.
 * 
 * See Modgen Developer's Guide for more information.
 */
void SetMaxTime(double max_value)
{
    fixed_precision_float<Time::type>::set_max(max_value);
}

/**
 * Start event trace.
 * 
 * See Modgen Developer's Guide for more information.
 */
void StartEventTrace()
{
    if (BaseEvent::trace_event_enabled) {
        BaseEvent::trace_event_on = true;
    }
}

/**
 * Stop event trace.
 * 
 * See Modgen Developer's Guide for more information.
 */
void StopEventTrace()
{
    if (BaseEvent::trace_event_enabled) {
        BaseEvent::trace_event_on = false;
    }
}

/**
 * Total number of threads used in simulation.
 * 
 * See Modgen Developer's Guide for more information.
 */
int GetThreads()
{
    return 1;
}

/**
 * Numeric identifier of current thread for current simulation
 * 
 * See Modgen Developer's Guide for more information.
 */
int GetThreadNumber()
{
    return 1;
}

/**
 * Sets the total population used for population scaling
 *
 * @param lPopulation The total population.
 */
void SetPopulation(long lPopulation)
{
    fmk::set_population_value = lPopulation;
}

/**
 * Gets the total population used for population scaling
 *
 * @return The population.
 */
long GetPopulation()
{
    return fmk::set_population_value;
}

/**
 * Tells the framework to exit all entities from the simulation after completion of the current event.
 */
void signal_exit_simulation_all()
{
    fmk::do_exit_simulation_all = true;
}


/**
 * Piece linear lookup.
 *
 * @param x  The x coordinate.
 * @param ax The array of x coordinates of the points
 * @param ay The array of y coordinates of the points
 * @param n  The number of x-y points
 *
 * @return The y value corresponding to x
 */
double PieceLinearLookup(double x, const double *ax, const double *ay, int n)
{
    double y = 0.0;

    if (x <= ax[0]) {
        // X is less than lower bound of first interval, return Y of lower bound of first interval.
        y = ay[0];
    }
    else {
        // a simple linear search
        bool found = false;
        for (int j = 1; j < n; ++j) {
            if (!(ax[j] > ax[j - 1])) {
                // non-increasing X, throw error
                ModelExit("error : non-increasing x in PieceLinearLookup");
                // NOT_REACHED
            }
            if (x < ax[j]) {
                found = true;
                // interpolate
                y = ay[j - 1] + (ay[j] - ay[j - 1]) / (ax[j] - ax[j - 1]) * (x - ax[j - 1]);
                break;
            }
        }
        if (!found) {
            // X is greater than upper bound of last interval, return Y of upper bound of last interval.
            y = ay[n - 1];
        }
    }
    return y;
}

/**
 * Query if the value x is a numeric quantity.
 * 
 * Used to determine if a table cell contains a numeric value, or is empty.
 *
 * @param x The double to be checked
 *
 * @return true if undefined, false if not.
 */
bool IsUndefined(double x)
{
    return std::isnan(x);
}